{
  "openapi": "3.0.0",
  "security": [
    {
      "X-API-Key": []
    }
  ],
  "info": {
    "title": "Tatum API Reference",
    "version": "3.17.0",
    "description": "# Welcome to the Tatum API Reference!\n\n## What is Tatum?\n\nTatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the\nTatum blockchain development framework, visit [our website](https://tatum.io/framework).\n\nThe Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all\nsupported blockchains using unified API calls.\n\n## Need help?\n\nTo chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join \nour [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum,\nreview the [online documentation](https://docs.tatum.io/).\n\n## About this API Reference\n\nThe Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few\n[vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.\n\n# Authentication\n\nWhen using the Tatum API, you authenticate yourself with an **API key**.\n<SecurityDefinitions />\n",
    "x-logo": {
      "url": "https://tatum.io/images/Light.svg",
      "altText": "Tatum"
    }
  },
  "servers": [
    {
      "url": "https://api.tatum.io"
    }
  ],
  "tags": [
    {
      "description": "<p>Interact with the blockchain directly by connecting to the blockchain node and communicating with it through JSON-RPC.</p>\n<p>Each node-related API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Node RPC"
    },
    {
      "description": "<p>A Tatum Account is the primary building block of Tatum-powered applications. It is an envelope that holds essential information about balances, the state of the account or customer, and to whom the account belongs.<br/><br/>\nAccounts in Tatum are stored within Tatum Private Ledger. Tatum Private Ledger contains information about accounts, the customers that own the accounts, transactions that affect the accounts or virtual currencies present in the ledger.<br/><br/>\nBy default, the private ledger is not connected to any blockchain. It is possible to create an application on it without any blockchain at all. Using Tatum Private Ledger and the building blocks included within it, it is possible to quickly swap the whole application from the ledger to any blockchain supported by Tatum. All of the API calls will remain the same, the only thing that changes is the blockchain the application lives on.<br/><br/>\nMost blockchains do not have any compliance layer at all. It is not possible to freeze funds at a blockchain address or deactivate an address. The Tatum Account has built-in compliance, and it is possible to block funds in the account, freeze outgoing transactions from the account or even completely deactivate the account.\n</p>\n",
      "name": "Account"
    },
    {
      "description": "<p>An endpoint used to create and list transactions within Tatum Private Ledger. A transaction is performed between 2 accounts with the same currency. To perform an exchange operation between accounts with different currencies, API calls from <a href=\"#tag/Order-BookLedger-Order-Book\">Order Book</a> sections are available. Transactions in the ledger are instant, with a settlement time of below 200ms.<br/>\nTatum Private Ledger supports microtransactions - a transaction of an amount as little as 1e-30 (30 decimal places). Transactions are atomic.<br/>\nWhen there is an insufficient balance in the sender account, or recipient account cannot receive funds, the transaction is not settled.</p>\n",
      "name": "Transaction"
    },
    {
      "description": "<p>An endpoint used to handle customer operations, like updating customer information, enabling/disabling etc.\nWithin Tatum API, a customer represents a client of the entity that communicates with Tatum.<br/>\nCustomers cannot be created via any other operation than Create Ledger Account.<br/>\nDue to compliance restrictions, it is recommended to enter the country of residence of the customer and the country of the provider. The Tatum compliance engine operates based on this information.\n</p>\n",
      "name": "Customer"
    },
    {
      "description": "<p>Register and use Tatum Private Ledger's virtual currencies. You can create your own virtual currency and distribute it amongst your customers.<br/>\nVirtual currencies are used to support FIAT currencies. When a virtual currency is created with basePair of the FIAT currency, it is possible to perform transactions in the private ledger in FIAT.\n</p>\n",
      "name": "Virtual Currency"
    },
    {
      "description": "<p>The gas pump is Tatum's feature that helps you manage gas fees in a custodial application. When you use the gas pump, gas fees for any transaction made by your customers (users of your custodial application) are automatically deducted from the master address instead of the customer's address. This eliminates the need to send crypto to each customer's address to pay for gas fees.</p>\n<p>For more information about the gas pump, see <a href=\"https://docs.tatum.io/gas-pump/pay-gas-fees-with-tatum-gas-pump\" target=\"_blank\">our user documentation</a>.</p>\n<p>Each API related to the gas pump supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Gas pump"
    },
    {
      "description": "<p>Endpoints to handle subscriptions to the Tatum Platform. Subscriptions allow users to enable some additional features or reports that are not enabled by default,\nlike outgoing off-chain transaction scanning, accounts with balances above the limit, etc.</p>\n",
      "name": "Notification subscriptions"
    },
    {
      "description": "<p>Endpoint to handle Order book operations like creating BID / ASK trades between Tatum Private Virtual accounts, obtaining trade histories, creating futures etc. It is possible to build an exchange based on the Ledger Accounts.</p>",
      "name": "Order Book"
    },
    {
      "description": "<p><a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System</a> (KMS) is a comprehensive solution for building custodial applications. KMS runs locally on your server and provides security for generating wallets, addresses, and private keys, and for signing transactions.</p>\n<p>KMS builds a list of pending transaction to sign and provides the options to complete a transaction after it has been signed and to obtain transaction details with the result of the blockchain operation via the transaction ID.</p>\n<p>In KMS, each managed wallet or private key is assigned a unique signature ID (<code>signatureId</code>) that represents that wallet or private key. This signature ID is then used in an API request to identify the wallet.</p>\n<p>Depending on the API, you can use the signature ID in an API call request in the following ways:</p>\n<ul>\n<li>\nTo represent the <b>mnemonic</b> type of the wallet; for example, in the <a href=\"https://apidoc.tatum.io/tag/Blockchain-operations#operation/BtcTransfer\" target=\"_blank\">API for sending BTC from a virtual account to the blockchain</a> (see the <code>transferBtcKMS</code> request schema).</li>\n<li>To represent the <b>privateKey</b> type of the wallet; for example, in the <a href=\"https://apidoc.tatum.io/tag/Bitcoin#operation/BtcTransferBlockchain\" target=\"_blank\">API for sending BTC to a blockchain address</a> (see the <code>BtcTransactionFromUTXOKMS</code> request schema).</li>\n<li>To represent the <b>mnemonic</b> and <b>index</b> type of the wallet; for example, in the <a href=\"https://apidoc.tatum.io/tag/Blockchain-operations#operation/EthTransfer\" target=\"_blank\">API for sending ETH from a virtual account to the blockchain</a> (see the <code>transferEthKMS</code> request schema).<br />In this case, the index of the specific private key generated from the mnemonic must be used in addition to the signature ID.</li>\n</ul>\n<p>You can run KMS on the following operating systems:</p>\n<ul>\n<li><b>macOS:</b> Natively or via <a href=\"https://hub.docker.com/repository/docker/tatumio/tatum-kms\" target=\"_blank\">Docker</a></li>\n<li><b>Unix:</b> Natively or via <a href=\"https://hub.docker.com/repository/docker/tatumio/tatum-kms\" target=\"_blank\">Docker</a></li>\n<li><b>MS Windows:</b> Only via <a href=\"https://hub.docker.com/repository/docker/tatumio/tatum-kms\" target=\"_blank\">Docker</a></li>\n</ul>\n<p>For more information about KMS, see the <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">KMS GitHub repository</a> and the <a href=\"https://docs.tatum.io/private-key-management/private-key-management\" target=\"_blank\">user documentation</a>.</p>\n</ul></p>\n",
      "name": "Key Management System"
    },
    {
      "description": "<p>An endpoint to check if the blockchain address is safe to work with or not.</p>\n",
      "name": "Malicious address"
    },
    {
      "description": "<p>Manage deposit addresses associated with your virtual account.</p>\n<p>Depending on how virtual accounts are connected to the blockchain, the virtual accounts can be:</p>\n<ul>\n<li><b>Virtual accounts with associated deposit addresses</b>\n<br/>Customers can send funds to and receive funds from other blockchain addresses.</li>\n<li><b>Virtual accounts with no deposit addresses</b>\n<br/>These accounts have a cryptocurrency assigned but do not have any associated deposit addresses. The customers can send funds to and receive funds from another virtual accounts and can send funds to blockchain addresses. However, the customers cannot receive funds from blockchain addresses.</li>\n</ul>\n",
      "name": "Blockchain addresses"
    },
    {
      "description": "<p>An endpoint to handle operations between Tatum Private Ledger and the blockchain, e.g. to create blockchain transactions from ledger accounts,\ncreate custom Ethereum ERC20 tokens, Stellar XLM, or Ripple XRP custom assets and register them as regular currency into the Tatum Private Ledger.</p>\n",
      "name": "Blockchain operations"
    },
    {
      "description": "<p>An endpoint used to create, cancel, or complete withdrawals by customers from Tatum to supported blockchains.\nWithdrawals are always multi-step operations that consist of the following steps:\n<ul>\n<li><b>create withdrawal</b></li>\n<li><b>perform blockchain transaction</b></li>\n<li><b>complete withdrawal</b></li>\n<li><b>cancel withdrawal</b>, when any of the previous operations fail</li>\n</ul>\n</p>\n",
      "name": "Withdrawals"
    },
    {
      "description": "<p>Bitcoin Blockchain enables access to the most commonly used Bitcoin methods. These methods bring a small level of abstraction\nand are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\nto connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain</li>\n<li>Testnet3 - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://testnet-faucet.mempool.co/\">https://testnet-faucet.mempool.co/</a></li></ul><br/>\n",
      "name": "Bitcoin"
    },
    {
      "description": "<p><a href=\"https://ethereum.org/\" target=\"_blank\">Ethereum</a> is a decentralized, open-source blockchain. With Tatum, you can access the most commonly used Ethereum methods. These methods bring a certain level of abstraction and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside virtual accounts to connect the blockchain and a virtual account, like generating a wallet or getting information about transactions.</p>\n<p>Tatum supports the following Ethereum networks:</p>\n<ul>\n<li><b>Mainnet</b>, the primary public production blockchain</li>\n<li><b>Sepolia</b>, a proof-of-work testnet and the default testnet for Ethereum. The testnet cryptocurrency has no value, and you can obtain it from a faucet (for example, <a target=\"_blank\" href=\"https://fauceth.komputing.org/\">FaucETH</a>).</li>\n</ul>\n",
      "name": "Ethereum"
    },
    {
      "description": "<p>IPFS is a distributed file storage. You can store data to IPFS and read from them.</p>\n",
      "name": "IPFS"
    },
    {
      "description": "<p>Bitcoin Cash Blockchain enables access to the most commonly used Bitcoin Cash methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://faucet.fullstack.cash/\">https://faucet.fullstack.cash/</a></li></ul>\n  </ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Bitcoin Cash"
    },
    {
      "description": "<p>Build a peer-to-peer NFT marketplace and allow your customers to sell and buy assets. When an asset is sold, the creator is automatically paid, the asset is instantly transferred to the buyer, and you as the owner of the marketplace automatically receive a percentage of the transaction.</p>\n<p>Each marketplace-related API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Marketplace"
    },
    {
      "description": "<p>The utility APIs help you use some native blockchain features such as getting the address of a smart contract or estimating the block number.</p>\n<p>Each utility API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Blockchain utils"
    },
    {
      "description": "<p>Litecoin Blockchain enables access to the most commonly used Litecoin methods. These methods bring a small level of abstraction and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"http://testnet.litecointools.com/\">http://testnet.litecointools.com/</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Litecoin"
    },
    {
      "description": "<p>Dogecoin Blockchain enables access to the most commonly used Dogecoin methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://testnet-faucet.com/doge-testnet/\">https://testnet-faucet.com/doge-testnet/</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Dogecoin"
    },
    {
      "description": "<p>Flow Blockchain enables access to the most commonly used Flow methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports FLOW and FUSD stable coin.<br/>\nTatum supports 2 chains:\n  <ul><li>Mainnet - a regular live chain</li>\n  <li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a target=\"_blank\" href=\"https://testnet-faucet.onflow.org/\">https://testnet-faucet.onflow.org/</a>\n<br/>To obtain FUSD on testnet, you can swap them using <a target=\"_blank\" href=\"https://swap-testnet.blocto.app/#/swap\">https://swap-testnet.blocto.app/#/swap</a></li></ul>\nTo create accounts or mint NFTs on <b>mainnet</b>, you have to have paid API Key. Tatum covers the transaction fees on FLOW blockchain out of the box, so mainnet operations are available only on the paid API Key.<br/>\nTatum handles automatically proposal key management - we internally rotate the proposal keys for you, so you don't have to take care of that and can easily scale your transaction throughput.<br/>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.<br/>\nIt's not possible to pregenerate addresses on the Flow blockchain. You can generate only public keys, which are used to generate address using a create account transaction to the Flow blockchain.\nYou have to have existing account on the Flow to initialize new address creation. Transactions on the Flow blockchain are free.</p>\n",
      "name": "Flow"
    },
    {
      "description": "<p>XRP Blockchain enables access to the most commonly used XRP methods. These methods bring a small level of abstraction\n and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n to connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\n Tatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain</li>\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a href=\"https://developers.ripple.com/xrp-test-net-faucet.html\" target=\"_blank\">https://developers.ripple.com/xrp-test-net-faucet.html</a>.</li></ul></p>\n<p><br/>In order to start using the XRP blockchain, we first need to create an XRP account. In XRP, the same account is used for the Mainnet and the Test chain. In order to have the account activated, it must be credited with 20 XRP. Because of this requirement, it is common to use one account for all customers and differentiate them via Destination tags, i.e. a number included in every transaction as an account distinguisher.<br/>\nWhen an off-chain deposit address is created for the ledger account, a Destination tag is generated, e.g. 12345 for that account. When a transaction to the blockchain is performed, it should contain the address of the recipient and the Destination tag as an account distinguisher.</p>\n",
      "name": "XRP"
    },
    {
      "description": "<p>XLM Blockchain enables access to the most commonly used XLM methods. These methods bring a small level of abstraction\nand are used for applications that communicate with the blockchain directly. Some of the methods are used alongside Tatum Private Ledger\nto connect the blockchain and the private ledger, like wallet generation or getting information about transactions.<br/>\nTatum supports 2 chains:\n<ul><li> Mainnet - a regular live chain</li>\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from a faucet, e.g. <a href=\"https://friendbot.stellar.org/?addr=address\" target=\"_blank\">https://friendbot.stellar.org/?addr=address</a>.</li></ul>\n<br/>In order to start using the XLM blockchain, we first need to create an XLM account. In order to have the account activated, it must be credited with 0.5 XLM.  Because of this requirement, it is common to use one account for all customers and differentiate them using a memo - a short text/number included in every transaction as an account distinguisher.<br/>\nWhen an off-chain deposit address is created for the ledger account, a memo is generated, e.g. 12345 for that account. When a transaction to the blockchain is performed, it should contain the address of the recipient and the memo as an account distinguisher.</p>\n",
      "name": "Stellar"
    },
    {
      "description": "<p>You can store data records on the blockchain. A record is stored permanently: it cannot be changed,\ndeleted, or modified by anyone and will be stored on the blockchain forever.\n",
      "name": "Blockchain storage"
    },
    {
      "description": "<p>Binance Blockchain enables access to most commonly used Binance methods.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://www.binance.com/en/dex/testnet/address\">https://www.binance.com/en/dex/testnet/address</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "BNB Beacon Chain"
    },
    {
      "description": "<p>VeChain Blockchain enables access to the most commonly used VeChain methods. Tatum does not support off-chain capabilities for the VET blockchain.\nTatum KMS is not supported for VET transactions. VET supports 2 native assets - VET and VTHO. VTHO is used for paying transaction fees.\n<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a test chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet.vecha.in/\">https://faucet.vecha.in/</a></li></ul>\nTatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "VeChain"
    },
    {
      "description": "<p><b>Support for Cardano is deprecated.</b></p>\n<s><p><b>Cardano is in maintenance mode.</b></p>\n<p><a href=\"https://cardano.org/\" target=\"_blank\">Cardano</a> is a decentralized, open-source blockchain. With Tatum, you can access the most commonly used Cardano methods. These methods bring a certain level of abstraction and are used for applications that communicate with the blockchain directly. Some of the methods are used alongside virtual accounts to connect the blockchain and a virtual account, like generating a wallet or getting information about transactions.</p>\n<p>Tatum supports Cardano mainnet and <a href=\"https://docs.cardano.org/cardano-testnet/getting-started\" target=\"_blank\">Cardano preproduction testnet</a>.</p></s>\n",
      "name": "Cardano"
    },
    {
      "description": "<p>Custodial API is a set of operations, which allows you to work with managed blockchain addresses without having its private key.\nYou can easily create new managed address and export its details - with private key as well - once required.<br/>\nThis features are currently in <b>Alpha version</b>.</p>\n",
      "name": "Custodial managed wallets"
    },
    {
      "description": "<p>\"NFT\" stands for \"Non-Fungible Token\", which means that each token is unique and irreplaceable. NFTs are described by the ERC-721 standard on the Ethereum blockchain or by the equivalent standard on the other blockchains.</p>\n<p>NFTs can be used for nearly any digital asset or good to ensure authenticity and scarcity, for example:<p>\n<ul>\n<li><b>In-game assets:</b> NFTs can be used to create unique collectibles in the form of characters, weapons, skins, or other equipment. Players can resell or trade assets directly as they choose, and their authenticity is easily verifiable.</li>\n<li><b>Music and other digital media:</b> NFTs can be used to create rare and unique collectible digital releases. Similarly, NFTs can be used to sell videos, art, or any other type of digital media. Collectors can own digital originals of their favorite songs, movies, and so on.</li>\n<li><b>Digital sports merchandise:</b> Trading cards, memorabilia, classic moments in sports history, and one-of-a-kind experiences can be sold as NFTs.</li>\n</ul>\n<p>Each NFT-related API its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "NFT (ERC-721 or compatible)"
    },
    {
      "description": "<p>Fungible tokens are interchangeable and are used as a blockchain representation of the currency. Fungible tokens are described by the ERC-20 standard on the Ethereum blockchain or by the equivalent standard on the other blockchains.</p>\n<p>Each API related to fungible tokens supports its own set of the blockchains. The list of the supported blockchains is provided in the operation description further in this section.</p>\n",
      "name": "Fungible Tokens (ERC-20 or compatible)"
    },
    {
      "description": "<p>A Multi Token combines characteristics of fungible and non-fungible tokens. A single Multi Token smart contract allows you to mint fungible, non-fungible, and semi-fungible tokens and process different types of the tokens in a single transaction. Multi Tokens are described by the ERC-1155 standard on the Ethereum blockchain or by the equivalent standard on the other blockchains.<p/>\n<p>Multi Tokens can be used for nearly any digital asset or good to ensure authenticity and scarcity, for example:<p>\n<ul>\n<li><b>In-game assets:</b> Multi Tokens can be used to create unique collectibles in the form of characters, weapons, skins, or other equipment. Players can resell or trade assets directly as they choose, and their authenticity is easily verifiable.</li>\n<li><b>Music and other digital media:</b> Multi Tokens can be used to create rare and unique collectible digital releases. Similarly, Multi Tokens can be used to sell videos, art, or any other type of digital media. Collectors can own digital originals of their favorite songs, movies, and so on.</li>\n<li><b>Digital sports merchandise:</b> Trading cards, memorabilia, classic moments in sports history, and one-of-a-kind experiences can be sold as Multi Tokens.</li>\n</ul>\n<p>Each Multi Token-related API supports its own set of the blockchains. The list of the supported blockchains is provided in the API description further in this section.</p>\n",
      "name": "Multi Tokens (ERC-1155 or compatible)"
    },
    {
      "description": "<p>Solana is a blockchain network focused on fast transactions and high throughput. It uses a unique method of ordering transactions to improve its speed. Users can pay their transaction fees and interact with smart contracts with SOL, the network's native cryptocurrency.<br/>\n<b>For now, Solana is in <b>BETA</b> and there is a rate limitation applied for all projects for Solana to 40 req/s on the platform.</b><br/>\nTatum supports 2 chains:\n<ul><li>Mainnet BETA - a regular live chain\n<li>Devnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://solfaucet.com/\">https://solfaucet.com/</a></li></ul></p>\n",
      "name": "Solana"
    },
    {
      "description": "<p>Binance Smart Chain is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://testnet.binance.org/faucet-smart\">https://testnet.binance.org/faucet-smart</a></li></ul></p>\n",
      "name": "BNB Smart Chain"
    },
    {
      "description": "<p>Polygon (Matic) is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Mumbai Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet.matic.network/\">https://faucet.matic.network/</a></li></ul></p>\n",
      "name": "Polygon"
    },
    {
      "description": "<p>Celo is fork of Celo with more than 1000 tps and possibility to pay for\ntransactions in it's own stable coin, cUSD. Celo Blockchain enables access to most commonly used Celo methods.\nThese methods bring small level of abstraction,\n       and are used for the type of applications that want to communicate with blockchain directly. Some of the methods are used alongside Tatum Private Ledger\n       to connect blockchain and private ledger together, like wallet generation or getting information about transactions.<br/>\n      Tatum supports 2 chains:\n      <ul><li>Mainnet - regular live chain\n      <li>Alfajorec - test chain used for testing purposes. Coins on test chain have no value and can be obtained from\n      Faucet, e.g. <a target=\"_blank\" href=\"https://celo.org/developers/faucet\">https://celo.org/developers/faucet</a></li></ul><br/>\n      Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. It is possible to generate this type of wallet with 1 simple API call.</p>\n",
      "name": "Celo"
    },
    {
      "description": "<p>Elrond (EGLD) is a distributed transactional computation protocol which relies on a sharded state architecture and a secure Proof of Stake consensus mechanism.\n<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Devnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://r3d4.fr/elrond/devnet/index.php\">https://r3d4.fr/elrond/devnet/</a></li></ul></p>\n",
      "name": "Elrond"
    },
    {
      "description": "<p>Algorand is a decentralized blockchain technology network. Algorand is enabling the simple creation of next generation financial products, protocols and exchange of value across defi, financial institutions and governments.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a></li></ul></p>\n",
      "name": "Algorand"
    },
    {
      "description": "<p>Tron Blockchain enables access to most commonly used Tron methods. It's possible to generate TRON account, send TRX, TRC10 and TRC20 assets. It's also possible to generate custom TRC10 or TRC20 tokens using API.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - regular live chain\n<li>Shasta Testnet - test chain used for testing purposes. Coins on test chain have no value and can be obtained from\nFaucet, e.g. <a target=\"_blank\" href=\"https://www.trongrid.io/shasta/\">https://www.trongrid.io/shasta/</a></li></ul>\n",
      "name": "Tron"
    },
    {
      "description": "<p>Klaytn is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Baobab Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://baobab.wallet.klaytn.com/access?next=faucet\">https://baobab.wallet.klaytn.com/access?next=faucet</a></li></ul></p>\n",
      "name": "Klaytn"
    },
    {
      "description": "<p>Harmony.ONE is an Oneeum L2 scaling solution 100% EVM compatible, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet.pops.one/\">https://faucet.pops.one/</a></li></ul></p>\n",
      "name": "Harmony"
    },
    {
      "description": "<p>XDC Network (XinFin) is enterprise ready hybrid blockchain for global trade and finance, combining the power of Public & Private blockchains with interoperable Smart Contracts.\n<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://apothem.network/#getTestXDC\">https://apothem.network/#getTestXDC</a></li></ul></p>\n",
      "name": "XinFin"
    },
    {
      "description": "<p>Kcs (KCS) is an Ethereum EVM 100% compatible blockchain, and is very good for decentralized application (Dapp) development within many possible verticals including DeFi, NFT, Gaming, and many others.<br/>\nTatum supports 2 chains:\n<ul><li>Mainnet - a regular live chain\n<li>Mumbai Testnet - a chain used for testing purposes. Coins on the test chain have no value and can be obtained from\na faucet, e.g. <a target=\"_blank\" href=\"https://faucet-testnet.kcc.network/\">https://faucet-testnet.kcc.network/</a></li></ul></p>\n",
      "name": "KuCoin"
    }
  ],
  "x-tagGroups": [
    {
      "name": "Blockchain",
      "tags": [
        "Node RPC",
        "Algorand",
        "Bitcoin",
        "Bitcoin Cash",
        "BNB Smart Chain",
        "BNB Beacon Chain",
        "Cardano",
        "Celo",
        "Dogecoin",
        "Elrond",
        "Ethereum",
        "Flow",
        "Harmony",
        "Klaytn",
        "KuCoin",
        "Litecoin",
        "Polygon",
        "Solana",
        "Stellar",
        "Tron",
        "VeChain",
        "XinFin",
        "XRP"
      ]
    },
    {
      "name": "Subscriptions",
      "tags": [
        "Notification subscriptions"
      ]
    },
    {
      "name": "Fee estimation",
      "tags": [
        "Blockchain fees",
        "Virtual account blockchain fees"
      ]
    },
    {
      "name": "Smart Contracts",
      "tags": [
        "NFT (ERC-721 or compatible)",
        "Fungible Tokens (ERC-20 or compatible)",
        "Multi Tokens (ERC-1155 or compatible)",
        "Gas pump",
        "Marketplace",
        "Auction"
      ]
    },
    {
      "name": "Security",
      "tags": [
        "Key Management System",
        "Malicious address",
        "Custodial managed wallets"
      ]
    },
    {
      "name": "Storage",
      "tags": [
        "IPFS",
        "Blockchain storage"
      ]
    },
    {
      "name": "Virtual Accounts",
      "tags": [
        "Account",
        "Transaction",
        "Customer",
        "Virtual Currency",
        "Order Book",
        "Withdrawal",
        "Blockchain addresses",
        "Blockchain operations",
        "Deposit"
      ]
    },
    {
      "name": "Utils",
      "tags": [
        "Blockchain utils",
        "Exchange rate",
        "Service utils"
      ]
    }
  ],
  "paths": {
    "/v3/blockchain/fee/{chain}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get recommended blockchain fee / gas price</p>\n",
        "operationId": "getBlockchainFee",
        "parameters": [
          {
            "description": "Chain",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "example": "BTC",
              "enum": [
                "ETH",
                "BTC",
                "LTC",
                "DOGE"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlockchainFee"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get recommended blockchain fee / gas price",
        "tags": [
          "Blockchain fees"
        ]
      }
    },
    "/v3/blockchain/estimate": {
      "post": {
        "description": "<h4>10 credits per API call.</h4><br/>\n<p>Estimate current transaction fee for different operations.<br/>\nSupported blockchains:\n<ul>\n<li>Bitcoin</li>\n<li>Litecoin</li>\n<li>Harmony.ONE</li>\n<li>The XDC Network</li>\n<li>Ethereum</li>\n<li>Celo</li>\n<li>Klaytn</li>\n<li>Binance Smart Chain</li>\n<li>Polygon</li>\n</ul>\n</p>\n",
        "operationId": "EstimateFeeBlockchain",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/EstimateFee"
                  },
                  {
                    "$ref": "#/components/schemas/EstimateFeeBatchMintNft"
                  },
                  {
                    "$ref": "#/components/schemas/EstimateFeeDeployCustodialWallet"
                  },
                  {
                    "$ref": "#/components/schemas/EstimateFeeTransferFromCustodial"
                  },
                  {
                    "$ref": "#/components/schemas/EstimateFeeFromAddress"
                  },
                  {
                    "$ref": "#/components/schemas/EstimateFeeFromUTXO"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "headers": {
              "x-current-block": {
                "schema": {
                  "type": "number",
                  "example": 15632152
                },
                "description": "Current block of the blockchain."
              },
              "x-current-block-time": {
                "schema": {
                  "type": "string",
                  "format": "date-time",
                  "example": "2021-11-11T11:54:49Z"
                },
                "description": "Current block time."
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/FeeBtc"
                    },
                    {
                      "$ref": "#/components/schemas/FeeETH"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Estimate the fee for a transaction",
        "tags": [
          "Blockchain fees"
        ]
      }
    },
    "/v3/polygon/gas": {
      "post": {
        "description": "<h4>2 credits per API call.</h4><br/>\n<p>Estimate gasLimit and gasPrice of the Polygon transaction. Gas price is obtained from <a href=\"https://gasstation-mainnet.matic.network/\" target=\"_blank\">https://gasstation-mainnet.matic.network/</a>.\n</p>\n",
        "operationId": "PolygonEstimateGas",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PolygonEstimateGas"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "gasLimit",
                    "gasPrice"
                  ],
                  "properties": {
                    "gasLimit": {
                      "type": "string",
                      "description": "Gas limit for transaction in gas price.",
                      "example": "40000"
                    },
                    "gasPrice": {
                      "type": "string",
                      "description": "Gas price in wei.",
                      "example": "20"
                    }
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Estimate Polygon transaction fees",
        "tags": [
          "Blockchain fees"
        ]
      }
    },
    "/v3/nft/deploy": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs.</p>\n<p>Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract <a href=\"https://github.com/tatumio/flow-contracts\" target=\"_blank\">here</a> (if the contract is deployed on Flow) or <a href=\"https://github.com/tatumio/smart-contracts/tree/master/contracts/tatum\" target=\"_blank\">here</a> (if the contract is deployed on any other supported blockchain).</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n<p><b>General NFT smart contracts</b><br/>\nBy default, an NFT smart contract is deployed as a <b>general NFT smart contract compatible with OpenSea royalties</b>. This is a standard NFT contract with <code>AccessControl</code> and <code>Ownable</code>, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure.<p>\n<p><b>Cashback and provenance NFT smart contracts</b><br/>\nIn addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains <b>except for Flow and TRON</b>:<p>\n<ul>\n<li><b>Cashback NFT smart contract</b> is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a <b>fixed value</b>. The royalties are <b>not</b> OpenSea-compatible.<br />\nTo deploy an NFT smart contract as a cashback contract, deploy the contract with the <code>cashback</code> parameter set to <code>true</code> in the request body.</li>\n<li><b>Provenance NFT smart contract</b> is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a <b>percentage of the NFT price</b>. The royalties are <b>not</b> OpenSea-compatible.<br />\nTo deploy an NFT smart contract as a provenance contract, deploy the contract with the <code>provenance</code> parameter set to <code>true</code> in the request body.</li>\n</ul>\n<p>You can enable <b>public minting</b> for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses <a href=\"#operation/NftAddMinter\">added to the smart contract as NFT minters</a> will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the <code>publicMint</code> parameter set to <code>true</code> in the request body.</p>\n<p><b>NFT smart contracts and NFT Express</b><br/>\nIf you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the <code>cashback</code>, <code>provenance</code>, and <code>publicMint</code> parameters either set to <code>false</code> or not set at all in the request body).<br/>\nAfter you have deployed the NFT smart contract, <a href=\"#operation/NftAddMinter\">add the Tatum minter address as an NFT minter to your smart contract</a>.</p>\n<p>For the complete information about using NFT Express on your smart contract, see \"Use your own smart contract to mint NFTs\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p>\n<p><b>Signing a transaction</b><br/>\nWhen deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftDeployErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/DeployNft"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftCelo"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftTron"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftKMS"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftCeloKMS"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftTronKMS"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftFlowPK"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftFlowMnemonic"
                  },
                  {
                    "$ref": "#/components/schemas/DeployNftFlowKMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Deploy an NFT smart contract",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/mint/add": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Allow a blockchain address (the <code>minter</code> parameter in the request body) to mint NFTs on the NFT smart contract (the <code>contractAddress</code> parameter in the request body).\n</br>Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter's address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \"Use your own smart contract to mint NFTs\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftAddMinter",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/AddNftMinter"
                  },
                  {
                    "$ref": "#/components/schemas/AddNftMinterKMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Add an NFT minter to an NFT smart contract",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/mint": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>You can mint NFTs using either of the following methods:</p>\n<ul>\n<li><a href=\"#NftExpress\">Using NFT Express</a></li>\n<li><a href=\"#NftNative\">Natively on a blockchain</a></li>\n</ul>\n<h3 id=\"NftExpress\">Minting NFTs using NFT Express</h3>\n<p>NFT Express is Tatum's feature that helps you mint NFTs easier than minting natively on a blockchain.</p>\n<ul>\n<li><b>You do not need to enter your private key or signature ID.</b><br/>NFT Express uses the private key provided by Tatum.</li>\n<li><b>You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions.</b>\n<ul>\n<li>To use NFT Express on the <b>mainnet</b>, you have to have a <a href=\"https://tatum.io/pricing\" target=\"_blank\">paid pricing plan</a>.<br/>Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan.<br/>The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on.</li>\n<li>On the <b>testnet</b>, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan.</li>\n</ul>\n</li>\n</ul>\n<p>With NFT Express, you can choose whether to mint NFTs on the <a href=\"#NftExpressPrebuilt\">pre-built NFT smart contract provided by Tatum</a> or on <a href=\"#NftExpressOwn\">your own smart contract</a>.</p>\n<h4 id=\"NftExpressPrebuilt\">Use the pre-built smart contract provided by Tatum to mint NFTs</h4>\n<p>If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum.<br/>The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet.<br/>\nFor more information, see <a href=\"https://docs.tatum.io/nft-express/mint-nfts-with-tatums-nft-express\" target=\"_blank\">our user documentation</a>.</p>\n<p>You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n<li>Solana</li>\n</ul>\n<p>Depending on what blockchain you use, choose the request body schema to use in the API call.</p>\n<ul>\n<li>To mint NFTs on <b>BNB Smart Chain</b>, <b>Celo</b>, <b>Ethereum</b>, <b>Harmony</b>, <b>Klaytn</b>, or <b>Polygon</b>, use this API with the <code>MintNftExpress</code> schema of the request body.</li>\n<li>To mint NFTs on <b>Algorand</b>, use this API with the <code>MintNftExpressAlgorand</code> schema of the request body.<br/>To be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFTs</a> any time later, specify the address of the manager account in the <code>manager</code> parameter.<br/>An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient's address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed.<br/>This how it works:\n<ol>\n<li>The recipient <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\" target=\"_blank\">agrees to receive the NFT</a> to their address.</li>\n<li>You <a href=\"#operation/NftTransferErc721\">transfer the NFT</a> to the recipient's address (use the <code>transferNftAlgoExpress</code> schema of the request body).<br /><b>NOTE:</b> On the <b>mainnet</b>, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the <b>testnet</b>, no credits are deducted from the monthly credit allowance.</li>\n</ol></li>\n<li>To mint NFTs on <b>Solana</b>, use this API with the <code>MintNftExpressSolana</code> schema of the request body.<br/>Solana uses the <a href=\"https://www.metaplex.com/\" target=\"_blank\">Metaplex Protocol</a>, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used.<br/>When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient's account address (the one in the <code>to</code> parameter of the request body). This address is returned in the <code>nftAccountAddress</code> parameter in the response body, is owned by the recipient's address, and has the same private key.<br/>The response body also returns the address of the minted NFT itself, which is held in the <code>nftAddress</code> parameter.<br/>After the NFT is minted, you have to <a href=\"#operation/NftTransferErc721\">transfer it</a> to the recipient's address (use the <code>transferNftSolana</code> or <code>transferNftSolanaKMS</code> schema of the request body). In the request body of the transfer call:\n<ul>\n<li>Set the <code>from</code> parameter to the address that you used in the <code>to</code> parameter in the request body of the minting call.</li>\n<li>Set the <code>to</code> parameter to the recipient's address.</li>\n<li>Set the <code>contractAddress</code> parameter to the address from the <code>nftAddress</code> parameter returned in the response body of the minting call.</li>\n<li>Set the <code>fromPrivateKey</code>/<code>signatureId</code> parameter to the private key/signature ID of the blockchain address that you specified in the <code>from</code> parameter.</li>\n</ul></li></ul>\n<h4 id=\"NftExpressOwn\">Use your own smart contract to mint NFTs</h4>\n<p>If you want to mint NFTs using your own smart contract, you are going to use an <b>NTF minter</b>, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan.</br>\n<b>IMPORTANT!</b> Your smart contract must be deployed as a <a href=\"#operation/NftDeployErc721\">general NFT smart contract</a>. You cannot use cashback and provenance smart contracts with NFT Express.</p>\n<p>For more information, see <a href=\"https://docs.tatum.io/nft-express/use-nft-express-with-your-own-smart-contract\" target=\"_blank\">our user documentation</a> and the <a href=\"https://blog.tatum.io/how-to-mint-nfts-using-tatums-nft-minter-965194d53c9f\" target=\"_blank\">article in the Tatum blog</a>.</p>\n<p>You can mint NFTs on your own smart contract on the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p>To mint NFTs using your own smart contract, do the following:</p>\n<ol>\n<li>In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet).</li>\n<li><a href=\"#operation/NftAddMinter\">Add the minter address as an NFT minter to your smart contract</a>.</li>\n<li>Use this API with the <code>MintNftMinter</code> schema of the request body.<br />In the request body, enter the following information:\n<ul>\n<li><code>chain</code> is the blockchain that you use.</li>\n<li><code>to</code> is the blockchain address where to send the minted NFT to.</li>\n<li><code>url</code> is the URL of the NFT metadata.</li>\n<li><code>minter</code> is the address of the NFT minter that you found in Step 1.</li>\n<li><code>contractAddress</code> is the address of your NFT smart contract.</li>\n<li><code>tokenId</code> is the the token ID of the NFT.<br />For example:\n<pre>\n{\n  \"chain\": \"CELO\",\n  \"to\": \"0x8ce4e40889a13971681391aad29e88efaf91f784\",\n  \"url\": \"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\",\n  \"contractAddress\": \"0x687422eEA2cB73B5d3e242bA5456b782919AFc85\",\n  \"tokenId\": \"0123\",\n  \"minter\": \"0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\"\n}\n</pre>\nWhen you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:\n<pre>\n{\n  \"chain\": \"CELO\",\n  \"to\": \"0x8ce4e40889a13971681391aad29e88efaf91f784\",\n  \"url\": \"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\",\n  \"contractAddress\": \"0x687422eEA2cB73B5d3e242bA5456b782919AFc85\",\n  \"tokenId\": \"0123\",\n  \"minter\": \"0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\",\n  \"fromPrivateKey\": \"0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\"\n}\n</pre>                               \n</li></ul></li>\n</ol>\n<p>The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains:</p>\n<table>\n  <tr>\n    <th>Blockchain</th>\n    <th>Minter address - testnet*</th>\n    <th>Minter address - mainnet</th>\n  </tr>\n  <tr>\n    <td>BNB Smart Chain</td>\n    <td>0xc16ae5e8c985b906935a0cadf4e24f0400531883</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Celo</td>\n    <td>0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Ethereum</td>\n    <td>0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Harmony</td>\n    <td>0x8906f62d40293ddca77fdf6714c3f63265deddf0</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Klaytn</td>\n    <td>0x80d8bac9a6901698b3749fe336bbd1385c1f98f2</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n  <tr>\n    <td>Polygon</td>\n    <td>0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5</td>\n    <td>0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94</td>\n  </tr>\n</table>\n<p>*If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain.</p>\n<h3 id=\"NftNative\">Minting NFTs natively on a blockchain</h3>\n<p>When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n<p>You can mint NFTs natively on the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>        \n<p>Depending on what blockchain you use, choose the request body schema to use in the API call.</p>\n<ul>\n<li>To mint NFTs natively on <b>Algorand</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftAlgorand</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftAlgorandKMS</code> schema of the request body.<br/><b>NOTE:</b><ul><li>To be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFTs</a> any time later, specify the address of the manager account in the <code>manager</code> parameter.</li><li>An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient's address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the <a href=\"#NftExpressPrebuilt\">pre-built NFT smart contract provided by Tatum</a>.</li></ul></li></ul></li>\n<li>To mint NFTs natively on <b>BNB Smart Chain</b>, <b>Ethereum</b>, <b>Harmony</b>, <b>Klaytn</b>, <b>KuCoin Community Chain</b>, or <b>Polygon</b>, and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNft</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftKMS</code> schema of the request body.</li></ul></li>\n<li>To mint NFTs natively on <b>Celo</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftCelo</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftKMSCelo</code> schema of the request body.</li></ul></li>\n<li>To mint NFTs natively on <b>Flow</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftFlowPK</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftFlowMnemonic</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>wallet mnemonic</b>, use this API the <code>MintNftFlowKMS</code> schema of the request body.</li></ul></li>\n<li>To mint NFTs natively on <b>Solana</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftSolana</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftSolanaKMS</code> schema of the request body.<br/><b>NOTE:</b> When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient's account address. After the NFT is minted, you have to transfer it to the recipient's address. For more information about how it works, see the section about minting NFTs on Solana using the <a href=\"#NftExpressPrebuilt\">pre-built NFT smart contract provided by Tatum</a>.</li></ul></li>\n<li>To mint NFTs natively on <b>TRON</b> and:\n<ul><li>To sign the transaction with your <b>private key</b>, use this API with the <code>MintNftTron</code> schema of the request body.</li>\n<li>To sign the transaction with your <b>signature ID</b>, use this API the <code>MintNftKMSTron</code> schema of the request body.</li></ul></li>\n</ul>\n",
        "operationId": "NftMintErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/MintNftExpress"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftExpressAlgorand"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftExpressSolana"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftMinter"
                  },
                  {
                    "$ref": "#/components/schemas/MintNft"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftKMS"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftAlgorand"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftAlgorandKMS"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftCelo"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftKMSCelo"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftFlowPK"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftFlowMnemonic"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftFlowKMS"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftSolana"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftSolanaKMS"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftTron"
                  },
                  {
                    "$ref": "#/components/schemas/MintNftKMSTron"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/FlowMintedResult"
                    },
                    {
                      "$ref": "#/components/schemas/SolanaMintedResult"
                    },
                    {
                      "$ref": "#/components/schemas/AlgorandMintedResult"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Mint an NFT",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/transaction": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Transfer an NFT from the smart contract (the <code>contractAddress</code> parameter in the request body) to the specified blockchain address (the <code>to</code> parameter in the request body).</p>\n<p>In one API call, you can transfer only one NFT.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n<p>For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the <code>safeTransfer()</code> method.</p>\n<p><b>Transferring NFTs on Algorand</b></p>\n<ul>\n<li>On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\" target=\"_blank\">has agreed to receive the NFT</a> to their address.</li>\n<li>If you want to transfer an NFT that <a href=\"#operation/NftMintErc721\">was minted using NFT Express</a>, use the <code>transferNftAlgoExpress</code> schema of the request body.<br /><b>NOTE:</b> On the <b>mainnet</b>, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the <b>testnet</b>, no credits are deducted from the monthly credit allowance.</li>\n</ul>\n<p><b>Transferring NFTs on Solana</b><br/>\nIf you want to transfer an NFT that <a href=\"#operation/NftMintErc721\">was minted using NFT Express</a>, see the section about minting NFTs on Solana using the <a href=\"#operation/NftMintErc721\">pre-built NFT smart contract provided by Tatum</a> for the information about how to set up the parameters in the request body.</p>\n<p><b>Signing a transaction</b><br/>\nWhen transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n<p><b>NOTE:</b> This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).</p>\n",
        "operationId": "NftTransferErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/TransferNft"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftCelo"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftTron"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftSolana"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftAlgo"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftAlgoExpress"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftFlowPK"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftFlowMnemonic"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftKMS"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftKMSCelo"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftAlgoKMS"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftSolanaKMS"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftFlowKMS"
                  },
                  {
                    "$ref": "#/components/schemas/TransferNftKMSTron"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Transfer an NFT",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/mint/batch": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\nThis operation works in two modes.\n\nFirst mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key.\nNo one should ever send it's own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey\nor signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production,\n<a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Tatum KMS</a> should be used for the highest security standards, and signatureId should be present in the request.\nAlternatively, using the Tatum client library for supported languages.\n\nSecond mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don't specify private key or signatureId, only minter address, from which the NFT will be minted.<br/>\nIt means you perform mint multiple NFT request with following body:\n<pre>{\n   \"to\": [\"0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\"],\n   \"url\": [\"ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\"],\n   \"tokenId\": [\"9876541124516\"],\n   \"contractAddress\":\"0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\",\n   \"minter\": \"0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\",\n   \"chain\": \"MATIC\"\n}</pre>\nThe blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan.\nWe transform fee to the credits in accordance to the rates provided by the Tatum.\nIf you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method:\n<pre>mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean</pre>\nYou can use addresses specified in the bellow table to be used as a minter.\n<table>\n  <tr>\n    <th>Chain</th>\n    <th>Testnet address</th>\n    <th>Mainnet Address</th>\n  </tr>\n  <tr>\n    <td>MATIC</td>\n    <td>0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>BSC</td>\n    <td>0xc16ae5e8c985b906935a0cadf4e24f0400531883</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>ONE</td>\n    <td>0x8906f62d40293ddca77fdf6714c3f63265deddf0</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>ETH</td>\n    <td>0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>CELO</td>\n    <td>0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n  <tr>\n    <td>KLAY</td>\n    <td>0x80d8bac9a6901698b3749fe336bbd1385c1f98f2</td>\n    <td>0xcf9e127455d28e7362380aec1b92ddee8200b295</td>\n  </tr>\n</table>\nIf there are not enough coins on any testnet address, feel free to send coins there.</p>\n",
        "operationId": "NftMintMultipleErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/MintMultipleNftMinter"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNft"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftCelo"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftTron"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftFlowPK"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftFlowMnemonic"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftKMS"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftKMSCelo"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftKMSTron"
                  },
                  {
                    "$ref": "#/components/schemas/MintMultipleNftFlowKMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/FlowMintedMultipleResult"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Mint multiple NFTs",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/burn": {
      "post": {
        "description": "<p><b>100 credits per API call on Flow<br/>\n2 credits per API call on the other blockchains</b></p>\n<p>Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n<p><b>Burning NFTs on Algorand</b><br/>\nYou can burn only the NFTs that were minted with the address of the manager account specified in the <code>manager</code> parameter in the <a href=\"#operation/NftMintErc721\">minting call</a> (see the <code>MintNftExpressAlgorand</code>, <code>MintNftAlgorand</code>, and <code>MintNftAlgorandKMS</code> schemas of the request body).</p>\n<p><b>Signing a transaction</b><br/>\nWhen burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftBurnErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/BurnNft"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftCelo"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftAlgo"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftKMSCelo"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftTron"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftKMSTron"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftKMS"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftFlowPK"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftFlowMnemonic"
                  },
                  {
                    "$ref": "#/components/schemas/BurnNftFlowKMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Burn an NFT",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/verify": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Verify an NFT in an NFT collection on Solana. Verifying an NFT sets the <code>Verified</code> parameter to <code>true</code> for the NFT, which means that the NFT is really a part of the collection. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>.</p>\n<p>The collection must be a sized collection that was introduced in <a href=\"https://docs.metaplex.com/programs/token-metadata/changelog/v1.3\" target=\"_blank\">Version 1.3</a> of the Metaplex Token Metadata program. The NFT must have been <a href=\"#operation/NftMintErc721\">minted in this collection</a>.</p>\n<p>This API is supported only for Solana.</p>\n<p><b>Signing a transaction</b><br/>\nWhen verifying an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftVerifyInCollection",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/VerifySolanaNFT"
                  },
                  {
                    "$ref": "#/components/schemas/VerifySolanaNFTKMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Verify an NFT in an NFT collection on Solana",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/transaction/{chain}/{address}/{tokenAddress}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get incoming and outgoing NFT transactions on a blockchain address.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "NftGetTransactionByAddress",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "CELO",
                "ETH",
                "MATIC"
              ],
              "example": "CELO"
            }
          },
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x8ce4e40889a13971681391aad29e88efaf91f784"
            }
          },
          {
            "description": "Address of the token smart contract",
            "in": "path",
            "name": "tokenAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x1ce4e40889a13971681391aad29e88efaf91f784"
            }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": {
              "type": "number",
              "example": 10,
              "maximum": 50,
              "minimum": 1
            },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": {
              "type": "number",
              "example": 0
            }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087623
            }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087823
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NftTx"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get NFT transactions on a blockchain address",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/transaction/tokenId/{chain}/{tokenAddress}/{tokenId}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p> <p>Get incoming and outgoing transactions for an NFT.</p> <p>This API is supported for the following blockchains:</p> <ul> <li>Celo</li> <li>Ethereum</li> <li>Polygon</li> </ul>",
        "operationId": "NftGetTransactionByToken",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "CELO",
                "ETH",
                "MATIC"
              ],
              "example": "CELO"
            }
          },
          {
            "description": "NFT Token ID.",
            "in": "path",
            "name": "tokenId",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          {
            "description": "Address of the token smart contract",
            "in": "path",
            "name": "tokenAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x1ce4e40889a13971681391aad29e88efaf91f784"
            }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": {
              "type": "number",
              "example": 10,
              "maximum": 50,
              "minimum": 1
            },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": {
              "type": "number",
              "example": 0
            }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087623
            }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087823
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NftTx"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get NFT transactions for an NFT",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/transaction/{chain}/{hash}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get an NFT transaction by its hash.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetTransactErc721",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ETH",
                "MATIC",
                "KCS",
                "ONE",
                "KLAY",
                "CELO",
                "TRON",
                "FLOW",
                "BSC"
              ]
            }
          },
          {
            "description": "The hash (ID) of the NFT transaction",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/CeloTx"
                    },
                    {
                      "$ref": "#/components/schemas/EthTx"
                    },
                    {
                      "$ref": "#/components/schemas/FlowTx"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get an NFT transaction by its hash",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/address/balance/{chain}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call + 5 credits for each owned NFT</b></p>\n<p>Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain - mainnet only</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n<li>Solana</li>\n</ul>\n<p>On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT's metadata. If the metadata is not returned, you can obtain it using the <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)/#operation/NftGetMetadataErc721\">API for getting NFT metadata</a>.</p>\n",
        "operationId": "NftGetTokensByAddressErc721",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "example": "SOL",
              "enum": [
                "ALGO",
                "BSC",
                "CELO",
                "ETH",
                "MATIC",
                "SOL"
              ]
            }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NftTokenByAddressErc721"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get all NFTs that a blockchain address holds",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/collection/{chain}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call + 5 credits for each listed NFT</b></p>\n<p>Get all NFTs from a collection (all the NFTs that were minted on the smart contract).</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "NftGetTokensByCollectionErc721",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "example": "ETH",
              "enum": [
                "CELO",
                "MATIC",
                "ETH"
              ]
            }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": {
              "type": "number",
              "example": 10,
              "maximum": 50,
              "minimum": 1
            },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": {
              "type": "number",
              "example": 0
            }
          },
          {
            "description": "The blockchain address of the collection",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x80d8bac9a6901698b3749fe336bbd1385c1f98f2"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NftTokenByCollectionErc721"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get all NFTs from a collection",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/balance/{chain}/{contractAddress}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the NFTs minted on a specific smart contract (the <code>contractAddress</code> path parameter in the request endpoint URL) that a blockchain address holds.</p>\n<p><b>NOTE:</b> This API works only for the NFT smart contracts deployed using the <a href=\"#operation/NftDeployErc721\">Tatum smart contract API</a>.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Elrond</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetBalanceErc721",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ETH",
                "MATIC",
                "KCS",
                "ONE",
                "KLAY",
                "CELO",
                "TRON",
                "FLOW",
                "BSC",
                "SOL",
                "ALGO",
                "EGLD"
              ]
            }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B"
            }
          },
          {
            "description": "The address of the NFT smart contract",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/NftGetBalanceScAlgo"
                    },
                    {
                      "$ref": "#/components/schemas/NftGetBalanceSc"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get the NFTs from a specific smart contract that a blockchain address holds",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/metadata/{chain}/{contractAddress}/{tokenId}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get metadata of an NFT.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetMetadataErc721",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "BSC",
                "CELO",
                "ETH",
                "FLOW",
                "KCS",
                "KLAY",
                "MATIC",
                "ONE",
                "SOL",
                "TRON"
              ]
            }
          },
          {
            "description": "The blockchain address of the NFT to get metadata for",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
            }
          },
          {
            "description": "The ID of the NFT to get metadata for<br/>Do <b>not</b> use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.",
            "in": "path",
            "name": "tokenId",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          {
            "description": "(Flow only) The account that holds the NFT",
            "in": "query",
            "required": false,
            "name": "account",
            "schema": {
              "type": "string",
              "example": "0xc1b45bc27b9c61c3"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NftMetadataErc721"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get NFT metadata",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/provenance/{chain}/{contractAddress}/{tokenId}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get provenance information for an NFT.</p>\n<p><b>NOTE:</b> This API works only for <a href=\"#operation/NftDeployErc721\">provenance NFT smart contracts</a>.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "NftGetProvenanceDataErc721",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "BSC",
                "CELO",
                "ETH",
                "KCS",
                "KLAY",
                "MATIC",
                "ONE"
              ]
            }
          },
          {
            "description": "The blockchain address of the NFT to get provenance information for",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
            }
          },
          {
            "description": "The ID of the NFT to get provenance information for.",
            "in": "path",
            "name": "tokenId",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/NftProvenanceDataErc721"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get NFT provenance information",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/royalty/{chain}/{contractAddress}/{tokenId}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get information about royalties for an NFT.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>TRON</li>\n</ul>\n",
        "operationId": "NftGetRoyaltyErc721",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "BSC",
                "CELO",
                "ETH",
                "KCS",
                "KLAY",
                "MATIC",
                "ONE",
                "SOL",
                "TRON"
              ]
            }
          },
          {
            "description": "The blockchain address of the NFT to get royalty information for",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
            }
          },
          {
            "description": "The ID of the NFT to get royalty information for<br/>Do <b>not</b> use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.",
            "in": "path",
            "name": "tokenId",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NftRoyaltyErc721"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get NFT royalty information",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/royalty": {
      "put": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Update the value of the royalty cashback set for an NFT.</p>\n<p>The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner.<br/>\nIn one API call, you can update the first value of the royalty cashback for the NFT author for one NFT.</p>\n<p>To disable the royalties for the NFT completely, set it to 0.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "NftUpdateCashbackErc721",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNft"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftCelo"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftTron"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftKMS"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftKMSCelo"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateCashbackValueForAuthorNftKMSTron"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Update NFT royalty information",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/nft/address/{chain}/{hash}": {
      "get": {
        "description": "<p><p>This endpoint is deprecated. Do not use it.<br/>\nInstead, use <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">this API</a>.</b></p><br/>\n<p><b>1 credit per API call</b></p>\n<p>Get NFT contract address from deploy transaction.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Flow</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>TRON</li>\n</ul>\n",
        "deprecated": true,
        "operationId": "NftGetContractAddress",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "ETH",
                "ONE",
                "KLAY",
                "CELO",
                "TRON",
                "FLOW",
                "MATIC",
                "KCS",
                "BSC"
              ]
            }
          },
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contractAddress": {
                      "type": "string",
                      "description": "Address of the NFT token.",
                      "example": "0xc21C81ef03f98898Fb155E00C364e8a7b9D158b8"
                    }
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get the address of an NFT smart contract by its transaction hash",
        "tags": [
          "NFT (ERC-721 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/deploy": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the <code>supply</code> parameter in the request body) will be transferred to the specified blockchain address (the <code>address</code> parameter in the request body).<br/>\nSmart contracts are standardized and audited.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>XinFin</li>\n</ul>\n<p>You can review the code of a deployed smart contract <a href=\"https://github.com/tatumio/tatum-middleware/blob/master/src/contracts/token.sol\" target=\"_blank\">here</a>.</p>\n<p><b>Signing a transaction</b><br/>\nWhen deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "Erc20Deploy",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ChainDeployErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeploySolanaSpl"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeployCeloErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeployKcsErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeployAlgoErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeployErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeploySolanaSplKMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeployCeloErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeployKcsErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainDeployAlgoErc20KMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Deploy a fungible token smart contract",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/mint": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Create new fungible tokens in the smart contract (the <code>contractAddress</code> parameter in the request body) and transfer them to the specified blockchain address (the <code>to</code> parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>XinFin</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "operationId": "Erc20Mint",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ChainMintErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainMintErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainMintKcsErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainMintKcsErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainMintCeloErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainMintCeloErc20KMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Mint fungible tokens",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/burn": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the <code>amount</code> parameter in the request body) from the smart contract (the <code>contractAddress</code> parameter in the request body).</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>XinFin</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "operationId": "Erc20Burn",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ChainBurnErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainBurnErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainBurnKcsErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainBurnKcsErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainBurnCeloErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainBurnCeloErc20KMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Burn fungible tokens",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/approve": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Allow a blockchain address (the <code>spender</code> parameter in the request body) to transfer and burn fungible tokens on behalf of the smart contract owner.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>Polygon</li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen allowing a blockchain address to transfer and burn fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "operationId": "Erc20Approve",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ApproveErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ApproveErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ApproveCeloErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ApproveCeloErc20KMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Allow a blockchain address to transfer and burn fungible tokens",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/transaction": {
      "post": {
        "description": "<p><b>2 credits per API call</b></p>\n<p>Transfer a supply of fungible tokens existing in the smart contract (the <code>contractAddress</code> parameter in the request body) to the specified blockchain address (the <code>to</code> parameter in the request body).<br/>\nTransferring fungible tokens invokes the <code>transfer()</code> method.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>XinFin</li>\n</ul>\n<p><b>Transferring fungible tokens on Algorand</b><br/>\nOn Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient <a href=\"https://apidoc.tatum.io/tag/Algorand#operation/AlgorandBlockchainReceiveAsset\" target=\"_blank\">has agreed to receive the NFT</a> to their address.</p>\n<p><b>Blockchain-specific APIs to transfer fungible tokens</b><br/>\nYou can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains:\n<ul>\n<li><a href=\"https://apidoc.tatum.io/tag/BNB-Smart-Chain#operation/BscBlockchainTransfer\" target=\"_blank\">BNB Smart Chain</a></li>\n<li><a href=\"https://apidoc.tatum.io/tag/Celo#operation/CeloBlockchainTransfer\" target=\"_blank\">Celo</a></li>\n<li><a href=\"https://apidoc.tatum.io/tag/Ethereum#operation/EthBlockchainTransfer\" target=\"_blank\">Ethereum</a></li>\n<li><a href=\"https://apidoc.tatum.io/tag/Harmony#operation/OneBlockchainTransfer\" target=\"_blank\">Harmony</a></li>\n<li><a href=\"https://apidoc.tatum.io/tag/KuCoin#operation/KcsBlockchainTransfer\" target=\"_blank\">KuCoin Community Chain</a></li>\n<li><a href=\"https://apidoc.tatum.io/tag/Polygon#operation/PolygonBlockchainTransfer\" target=\"_blank\">Polygon</a></li>\n<li><a href=\"https://apidoc.tatum.io/tag/XinFin#operation/XdcBlockchainTransfer\" target=\"_blank\">XinFin</a></li>\n</ul>\n<p><b>Signing a transaction</b><br/>\nWhen transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "parameters": [
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "operationId": "Erc20Transfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ChainTransferEthErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferSolanaSpl"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferBscBep20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferCeloErc20Token"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferAlgoErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferKcsEthErc20"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferEthErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferSolanaSplKMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferBscBep20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferCeloErc20TokenKMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferAlgoErc20KMS"
                  },
                  {
                    "$ref": "#/components/schemas/ChainTransferKcsEthErc20KMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Transfer fungible tokens",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/transaction/{chain}/{address}/{tokenAddress}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get incoming and outgoing transactions related to fungible tokens on a blockchain address.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n</ul>\n",
        "operationId": "Erc20GetTransactionByAddress",
        "parameters": [
          {
            "description": "The blockchain to work with",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "CELO",
                "ALGO",
                "MATIC",
                "ETH"
              ],
              "example": "CELO"
            }
          },
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x8ce4e40889a13971681391aad29e88efaf91f784"
            }
          },
          {
            "description": "Address of the token smart contract",
            "in": "path",
            "name": "tokenAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x1ce4e40889a13971681391aad29e88efaf91f784"
            }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": {
              "type": "number",
              "example": 10,
              "maximum": 50,
              "minimum": 1
            },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": {
              "type": "number",
              "example": 0
            }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087623
            }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087823
            }
          },
          {
            "description": "Sorting of the data. ASC - oldest first, DESC - newest first.",
            "in": "query",
            "name": "sort",
            "schema": {
              "type": "string",
              "default": "DESC",
              "example": "ASC",
              "enum": [
                "ASC",
                "DESC"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FungibleTx"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get fungible token transactions on a blockchain address",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/balance/{chain}/{contractAddress}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the number of the fungible tokens minted on a specific smart contract (the <code>contractAddress</code> path parameter in the request endpoint URL) that a blockchain address holds.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>BNB Smart Chain</li>\n<li>Celo</li>\n<li>Elrond</li>\n<li>Ethereum</li>\n<li>Harmony</li>\n<li>Klaytn</li>\n<li>KuCoin Community Chain</li>\n<li>Polygon</li>\n<li>Solana</li>\n<li>XinFin</li>\n</ul>\n",
        "operationId": "Erc20GetBalance",
        "parameters": [
          {
            "description": "Network name",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "CELO",
                "ALGO",
                "MATIC",
                "ETH",
                "BSC",
                "XDC",
                "KLAY",
                "ONE",
                "EGLD",
                "KCS",
                "SOL"
              ],
              "example": "CELO"
            }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B"
            }
          },
          {
            "description": "The address of the fungible token smart contract",
            "in": "path",
            "name": "contractAddress",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
            }
          },
          {
            "description": "Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored.",
            "in": "header",
            "name": "x-testnet-type",
            "required": false,
            "schema": {
              "default": "ethereum-sepolia",
              "type": "string",
              "enum": [
                "ethereum-sepolia"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Erc20Balance"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get the number of fungible tokens that a blockchain address holds in a smart contract",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/blockchain/token/address/{chain}/{address}": {
      "get": {
        "description": "<p><b>1 credit per API call</b></p>\n<p>Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on.</p>\n<p>This API is supported for the following blockchains:</p>\n<ul>\n<li>Algorand</li>\n<li>Celo</li>\n<li>Ethereum</li>\n<li>Polygon</li>\n<li>Solana</li>\n</ul>\n",
        "operationId": "Erc20GetBalanceAddress",
        "parameters": [
          {
            "description": "Network name",
            "in": "path",
            "name": "chain",
            "required": true,
            "schema": {
              "type": "string",
              "example": "CELO",
              "enum": [
                "CELO",
                "ETH",
                "MATIC",
                "SOL",
                "ALGO"
              ]
            }
          },
          {
            "description": "The blockchain address that you want to get the token balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Erc20BalanceForAddress"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get the number of fungible tokens that a blockchain address holds across a blockchain",
        "tags": [
          "Fungible Tokens (ERC-20 or compatible)"
        ]
      }
    },
    "/v3/polygon/wallet": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys.<br/>Each address is identified by 3 main values:<ul><li>Private Key - your secret value, which should never be revealed</li><li>Public Key - public address to be published</li><li>Derivation index - index of generated address</li></ul></p><p>Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m'/44'/966'/0'/0. More about BIP44 HD wallets can be found here - <a target=\"_blank\" href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki</a>.\nGenerate BIP44 compatible Polygon wallet.</p>\n",
        "operationId": "PolygonGenerateWallet",
        "parameters": [
          {
            "description": "Mnemonic to use for generation of extended public and private keys.",
            "in": "query",
            "name": "mnemonic",
            "required": false,
            "schema": {
              "type": "string",
              "maxLength": 500
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Wallet"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Generate Polygon wallet",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/address/{xpub}/{index}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate\nup to 2^31 addresses starting from index 0 until 2^31.</p>\n",
        "operationId": "PolygonGenerateAddress",
        "parameters": [
          {
            "description": "Extended public key of wallet.",
            "in": "path",
            "name": "xpub",
            "required": true,
            "schema": {
              "type": "string",
              "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid"
            }
          },
          {
            "description": "Derivation index of desired address to be generated.",
            "in": "path",
            "name": "index",
            "required": true,
            "example": 1,
            "schema": {
              "type": "number",
              "example": 0
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GeneratedAddressMatic"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Generate Polygon account address from Extended public key",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/wallet/priv": {
      "post": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic\ncan generate up to 2^31 private keys starting from index 0 until 2^31.</p>\n",
        "operationId": "PolygonGenerateAddressPrivateKey",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PrivKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PrivKey"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Generate Polygon private key",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/web3/{xApiKey}": {
      "post": {
        "deprecated": true,
        "description": "<p><b>2 credits per API call</b></p>\n<p><b>This endpoint is deprecated. Use the <a href=\"https://apidoc.tatum.io/tag/Node-RPC\" target=\"_blank\">HTTP-based JSON RPC driver</a> instead.</b></p><br/>\n<p>Use this endpoint URL as a http-based web3 driver to connect directly to the Polygon node provided by Tatum.\nTo learn more about Polygon Web3, visit the <a href=\"https://docs.matic.network/\" target=\"_blank\">Polygon developer's guide</a>.</p>\n",
        "operationId": "PolygonWeb3Driver",
        "parameters": [
          {
            "description": "Tatum X-API-Key used for authorization.",
            "in": "path",
            "name": "xApiKey",
            "required": true,
            "schema": {
              "type": "string",
              "example": "asdlkfjnqunalkwjfnq2oi303294857k"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Any valid Web3 method content body.",
                "example": {
                  "jsonrpc": "2.0",
                  "method": "web3_clientVersion",
                  "params": [],
                  "id": 2
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Any valid Web3 response.",
                  "example": {
                    "jsonrpc": "2.0",
                    "id": 2,
                    "result": "Geth/v1.9.9-omnibus-e320ae4c-20191206/linux-amd64/go1.13.4"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "x-codeSamples": [],
        "summary": "Web3 HTTP driver",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/block/current": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon current block number. This is the number of the latest block in the blockchain.</p>\n",
        "operationId": "PolygonGetCurrentBlock",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "description": "Current block number",
                  "example": 6491272
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get current block number",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/block/{hash}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon block by block hash or block number.</p>\n",
        "operationId": "PolygonGetBlock",
        "parameters": [
          {
            "description": "Block hash or block number",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "6470657"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EthBlock"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get Polygon block by hash",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/account/balance/{address}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.</p>\n",
        "operationId": "PolygonGetBalance",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x3223AEB8404C7525FcAA6C512f91e287AE9FfE7B"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MaticBalance"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get Polygon Account balance",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/transaction/{hash}": {
      "get": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Get Polygon transaction by transaction hash.</p>\n",
        "operationId": "PolygonGetTransaction",
        "parameters": [
          {
            "description": "Transaction hash",
            "in": "path",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PolygonTx"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get Polygon Transaction",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/account/transaction/{address}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.</p>\n",
        "operationId": "PolygonGetTransactionByAddress",
        "parameters": [
          {
            "description": "Account address you want to get balance of",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "example": "0x8ce4e40889a13971681391aad29e88efaf91f784"
            }
          },
          {
            "description": "Max number of items per page is 50.",
            "in": "query",
            "name": "pageSize",
            "schema": {
              "type": "number",
              "example": 10,
              "maximum": 50,
              "minimum": 1
            },
            "required": true
          },
          {
            "description": "Offset to obtain next page of the data.",
            "in": "query",
            "name": "offset",
            "schema": {
              "type": "number",
              "example": 0
            }
          },
          {
            "description": "Transactions from this block onwards will be included.",
            "in": "query",
            "name": "from",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087623
            }
          },
          {
            "description": "Transactions up to this block will be included.",
            "in": "query",
            "name": "to",
            "schema": {
              "type": "number",
              "minimum": 0,
              "example": 1087823
            }
          },
          {
            "description": "Sorting of the data. ASC - oldest first, DESC - newest first.",
            "in": "query",
            "name": "sort",
            "schema": {
              "type": "string",
              "default": "DESC",
              "example": "ASC",
              "enum": [
                "ASC",
                "DESC"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PolygonTx"
                  }
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get Polygon transactions by address",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/transaction/count/{address}": {
      "get": {
        "description": "<b><p>1 credit per API call</p></b>\n<p>Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions,\nwhich are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents\nthe order of the transaction in the list of outgoing transactions.</p>\n",
        "operationId": "PolygonGetTransactionCount",
        "parameters": [
          {
            "description": "address",
            "in": "path",
            "name": "address",
            "required": true,
            "schema": {
              "type": "string",
              "maxLength": 42,
              "minLength": 42,
              "example": "0xdac17f958d2ee523a2206206994597c13d831ec7"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "number",
                  "example": 5,
                  "description": "Number of transactions, that were made from this address. Can be used as a nonce parameter in send transaction calls."
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Get count of outgoing Polygon transactions",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/transaction": {
      "post": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Send MATIC from account to account.<br/><br/>\n<p><b>Signing a transaction</b></p>\n<p>When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "PolygonBlockchainTransfer",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/TransferPolygonBlockchain"
                  },
                  {
                    "$ref": "#/components/schemas/TransferPolygonBlockchainKMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Send MATIC from account to account",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/smartcontract": {
      "post": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Invoke a method in an existing smart contract on Polygon.</p>\n<p>You can call a read-only or write method.</p>\n<ul>\n<li>For <b>read-only</b> methods, the output of the invoked method is returned.</li>\n<li>For <b>write</b> methods, the ID of the associated transaction is returned.</li>\n</ul>        \n<p><b>Signing a transaction</b></p>\n<p>When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted.</p>\n<p>If <b>caller</b> field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method.</p>\n<p>Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the <b>testnet</b> of a blockchain.</p>\n<p>For signing transactions on the <b>mainnet</b>, we strongly recommend that you use the Tatum <a href=\"https://github.com/tatumio/tatum-kms\" target=\"_blank\">Key Management System (KMS)</a> and provide the signature ID instead of the private key in the API. Alternatively, you can use the <a href=\"https://github.com/tatumio/tatum-js\" target=\"_blank\">Tatum JavaScript client</a>.</p>\n",
        "operationId": "PolygonBlockchainSmartContractInvocation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CallPolygonSmartContractReadMethod"
                  },
                  {
                    "$ref": "#/components/schemas/CallPolygonSmartContractMethod"
                  },
                  {
                    "$ref": "#/components/schemas/CallPolygonSmartContractMethodCaller"
                  },
                  {
                    "$ref": "#/components/schemas/CallPolygonSmartContractMethodKMS"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TransactionHash"
                    },
                    {
                      "$ref": "#/components/schemas/SignatureId"
                    },
                    {
                      "$ref": "#/components/schemas/Data"
                    }
                  ]
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Invoke a method in a smart contract on Polygon",
        "tags": [
          "Polygon"
        ]
      }
    },
    "/v3/polygon/broadcast": {
      "post": {
        "description": "<b><p>2 credits per API call</p></b>\n<p>Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries.\nIt is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.</p>\n",
        "operationId": "PolygonBroadcast",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BroadcastKMS"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransactionHash"
                }
              }
            },
            "description": "OK"
          }
        },
        "security": [
          {
            "X-API-Key": []
          }
        ],
        "x-codeSamples": [],
        "summary": "Broadcast signed Polygon transaction",
        "tags": [
          "Polygon"
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "BroadcastKMS": {
        "properties": {
          "txData": {
            "description": "Raw signed transaction to be published to network.",
            "example": "62BD544D1B9031EFC330A3E855CC3A0D51CA5131455C1AB3BCAC6D243F65460D",
            "maxLength": 500000,
            "minLength": 1,
            "type": "string"
          },
          "signatureId": {
            "description": "ID of prepared payment template to sign. Required only, when broadcasting transaction signed by Tatum KMS.",
            "format": "uuid",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string"
          }
        },
        "required": [
          "txData"
        ],
        "type": "object"
      },
      "EthBlock": {
        "type": "object",
        "properties": {
          "difficulty": {
            "description": "Difficulty for this block.",
            "type": "string",
            "example": "3296820833"
          },
          "extraData": {
            "description": "The 'extra data' field of this block.",
            "type": "string",
            "example": "0x"
          },
          "gasLimit": {
            "description": "The maximum gas allowed in this block.",
            "type": "number",
            "example": 8000000
          },
          "gasUsed": {
            "description": "The total used gas by all transactions in this block.",
            "type": "number",
            "example": 7985124
          },
          "hash": {
            "description": "Hash of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "logsBloom": {
            "description": "The bloom filter for the logs of the block. 'null' when its pending block.",
            "type": "string",
            "example": "0x042080004210492080800001610060ad9600005bc81502020800000043e302020381a404000100409102040240300641108004000400007000008000c049558055a800000a0001800748900806502004200400108205005418c0218802281a0408060000533210462021050470810a010140102809011814018281115020090201068401847000a04010000c00084062000485640d00020220181150020008589105a41c0880001112034100010882545410240011402a3480050104004c310204000002009490d0012022a040c20c20011020401020140250805100410060008280200008181a220114102800001648640828200c00a94c1003a2060e001000"
          },
          "miner": {
            "description": "The address of the beneficiary to whom the mining rewards were given.",
            "type": "string",
            "example": "0xD8869d9E3d497323561Fbca2319a9FC3F6f10c4B"
          },
          "mixHash": {
            "description": "",
            "type": "string",
            "example": "0x7a44a1f56f12ae825fdc04550d7c3af2344daab987691771c06235f25fafcaa6"
          },
          "nonce": {
            "description": "Hash of the generated proof-of-work. 'null' when its pending block.",
            "type": "string",
            "example": "0xfa1692f52a7ac672"
          },
          "number": {
            "description": "The block number. 'null' when its pending block.",
            "type": "number",
            "example": 6470657
          },
          "parentHash": {
            "description": "Hash of the parent block.",
            "type": "string",
            "example": "0xd34aab8a455027086ac54034e68608c84d984401a883b7b5d91f9ae0bbefda15"
          },
          "receiptsRoot": {
            "description": "",
            "type": "string",
            "example": "0x4a496b6b7f2a1c5850bf9eebbea7193807be0067b1c06f17b9dde4eef7b2f960"
          },
          "sha3Uncles": {
            "description": "SHA3 of the uncles data in the block.",
            "type": "string",
            "example": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
          },
          "size": {
            "description": "The size of this block in bytes.",
            "type": "number",
            "example": 15296
          },
          "stateRoot": {
            "description": "The root of the final state trie of the block.",
            "type": "string",
            "example": "0x32757c92f10c6c5a106c6fb4b9ca3ff301e413a59ca3d0513b4bf98c72efddba"
          },
          "timestamp": {
            "description": "The unix timestamp for when the block was collated.",
            "type": "number",
            "example": 1569600592
          },
          "totalDifficulty": {
            "description": "Total difficulty of the chain until this block.",
            "type": "string",
            "example": "23329673338013873"
          },
          "transactions": {
            "description": "Array of transactions.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EthTx"
            }
          },
          "transactionsRoot": {
            "description": "The root of the transaction trie of the block.",
            "type": "string",
            "example": "0x5990081ef8515d561b50255af03c5d505f7725ddef27405dc67d23bfd0f47704"
          }
        }
      },
      "FlowTx": {
        "type": "object",
        "properties": {
          "referenceBlockId": {
            "description": "Id of the block",
            "type": "string",
            "example": "ad8b9ab637d56e19188cd5410db6e993fbf66216296c99f7934cf9f3594f9658"
          },
          "script": {
            "description": "Script to execute in the transaction",
            "type": "string"
          },
          "args": {
            "description": "Args to the transaction",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "example": "Address"
                },
                "value": {
                  "type": "string",
                  "example": "0x21cbd745a4df66f1"
                }
              }
            }
          },
          "gasLimit": {
            "type": "number",
            "example": 1000,
            "description": "Gas limit for the transaction"
          },
          "proposalKey": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "example": "21cbd745a4df66f1"
              },
              "keyId": {
                "type": "number",
                "example": 0
              },
              "sequenceNumber": {
                "type": "number",
                "example": 20
              }
            }
          },
          "payer": {
            "type": "string",
            "description": "Address from which the assets and fees were debited",
            "example": "955cd3f17b2fd8ad"
          },
          "payloadSignatures": {
            "description": "Array of payload signatures.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "example": "21cbd745a4df66f1"
                },
                "keyId": {
                  "type": "number",
                  "example": 0
                },
                "signature": {
                  "type": "string",
                  "example": "17a936b93b405f74af8ed4c70884ef10d98e900d04fb05bf12767e64ce5e498194348a13952c86335f56c8638fbfd0b1efde66b87e6df9ad687833709f9bd3f3"
                }
              }
            }
          },
          "envelopeSignatures": {
            "description": "Array of envelope signatures.",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "example": "21cbd745a4df66f1"
                },
                "keyId": {
                  "type": "number",
                  "example": 0
                },
                "signature": {
                  "type": "string",
                  "example": "17a936b93b405f74af8ed4c70884ef10d98e900d04fb05bf12767e64ce5e498194348a13952c86335f56c8638fbfd0b1efde66b87e6df9ad687833709f9bd3f3"
                }
              }
            }
          },
          "status": {
            "type": "number",
            "example": 4,
            "description": "Status of the transaction"
          },
          "statusCode": {
            "type": "number",
            "example": 0,
            "description": "Status cofe of the transaction"
          },
          "errorMessage": {
            "type": "string"
          },
          "events": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "example": "A.7e60df042a9c0868.FlowToken.TokensWithdrawn"
                },
                "transactionId": {
                  "type": "string",
                  "example": "d1c75a84e4bdf0dd9bf1bcd0ce4fb25f89e2ed3c5e9574dbca2760b52c428717"
                },
                "transactionIndex": {
                  "type": "number",
                  "example": 0
                },
                "eventIndex": {
                  "type": "number",
                  "example": 0
                },
                "data": {
                  "type": "object",
                  "description": "Event specific data. May vary."
                }
              }
            }
          }
        }
      },
      "EthTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "description": "Block number where this transaction was in.",
            "example": 6470854,
            "type": "number",
            "nullable": true
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": {
            "type": "number",
            "description": "Gas provided by the sender.",
            "example": 21000
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "description": "Integer of the transactions index position in the block.",
            "example": 3,
            "type": "number",
            "nullable": true
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000,
            "type": "number",
            "nullable": true
          },
          "cumulativeGasUsed": {
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159,
            "type": "number",
            "nullable": true
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "$ref": "#/components/schemas/EthTxLog"
            }
          }
        }
      },
      "EthTxLog": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "From which this event originated from.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "topics": {
            "type": "array",
            "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
            "items": {
              "type": "string",
              "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
            }
          },
          "data": {
            "type": "string",
            "description": "The data containing non-indexed log parameter."
          },
          "logIndex": {
            "type": "number",
            "description": "Integer of the event index position in the block."
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transaction’s index position, the event was created in."
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction this event was created in.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          }
        }
      },
      "FeeETH": {
        "type": "object",
        "required": [
          "gasLimit",
          "gasPrice"
        ],
        "properties": {
          "gasLimit": {
            "type": "number",
            "description": "Gas limit for transaction in gas price.",
            "example": 40000
          },
          "gasPrice": {
            "type": "number",
            "description": "Gas price in Gwei.",
            "example": 20
          }
        }
      },
      "FeeBtc": {
        "type": "object",
        "required": [
          "fast",
          "medium",
          "slow"
        ],
        "properties": {
          "fast": {
            "type": "string",
            "description": "Transaction fee in BTC|LTC to be paid, if transaction should be included in next 1-2 blocks.",
            "example": "0.006584"
          },
          "medium": {
            "type": "string",
            "description": "Transaction fee in BTC|LTC to be paid, if transaction should be included in next 5-6 blocks.",
            "example": "0.004584"
          },
          "slow": {
            "type": "string",
            "description": "Transaction fee in BTC|LTC to be paid, if transaction should be included in next 7+ blocks.",
            "example": "0.002584"
          }
        }
      },
      "EstimateFee": {
        "type": "object",
        "required": [
          "chain",
          "type"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": [
              "CELO",
              "ETH",
              "BSC",
              "XDC",
              "ONE",
              "MATIC",
              "KLAY"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": [
              "DEPLOY_ERC20",
              "DEPLOY_NFT",
              "MINT_NFT",
              "BURN_NFT",
              "TRANSFER_NFT",
              "TRANSFER_ERC20",
              "DEPLOY_AUCTION",
              "DEPLOY_MARKETPLACE"
            ]
          },
          "sender": {
            "type": "string",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "description": "Sender address, if type is TRANSFER_ERC20"
          },
          "recipient": {
            "description": "Blockchain address to send assets, if type is TRANSFER_ERC20",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "contractAddress": {
            "description": "Contract address of ERC20 token, if type is TRANSFER_ERC20",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in ERC20, if type is TRANSFER_ERC20",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          }
        }
      },
      "EstimateFeeDeployCustodialWallet": {
        "type": "object",
        "required": [
          "chain",
          "type",
          "batchCount"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": [
              "CELO",
              "ETH",
              "BSC",
              "XDC",
              "ONE",
              "MATIC",
              "KLAY"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": [
              "DEPLOY_CUSTODIAL_WALLET_BATCH"
            ]
          },
          "batchCount": {
            "description": "Number of addresses to create",
            "example": 10,
            "minimum": 1,
            "maximum": 300,
            "type": "number"
          }
        }
      },
      "EstimateFeeBatchMintNft": {
        "type": "object",
        "required": [
          "chain",
          "type",
          "sender",
          "recipients",
          "tokenIds",
          "urls"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": [
              "CELO",
              "ETH",
              "BSC",
              "XDC",
              "ONE",
              "MATIC",
              "KLAY"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": [
              "MINT_NFT_BATCH"
            ]
          },
          "sender": {
            "type": "string",
            "maxLength": 42,
            "minLength": 43,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "description": "Address of the minter"
          },
          "recipients": {
            "type": "array",
            "description": "Blockchain addresses to mint tokens to",
            "items": {
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
              "maxLength": 42,
              "minLength": 43,
              "type": "string"
            }
          },
          "contractAddress": {
            "description": "Contract address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 43,
            "type": "string"
          },
          "tokenIds": {
            "type": "array",
            "description": "Token IDs",
            "items": {
              "example": "100000",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          },
          "urls": {
            "type": "array",
            "description": "Metadata URLs",
            "items": {
              "example": "ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj",
              "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
              "type": "string"
            }
          }
        }
      },
      "EstimateFeeTransferFromCustodial": {
        "type": "object",
        "required": [
          "chain",
          "type",
          "sender",
          "recipient",
          "contractAddress",
          "custodialAddress",
          "amount",
          "tokenType"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": [
              "CELO",
              "ETH",
              "BSC",
              "XDC",
              "KLAY",
              "ONE",
              "MATIC"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": [
              "TRANSFER_CUSTODIAL"
            ]
          },
          "sender": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address"
          },
          "recipient": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "contractAddress": {
            "description": "Contract address of the token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "custodialAddress": {
            "description": "Contract address of custodial wallet contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in native asset, ERC20 or ERC1155",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "tokenType": {
            "description": "Type of the token to transfer from gas pump wallet. 0 - ERC20, 1 - ERC721, 2 - ERC1155, 3 - native asset",
            "example": 0,
            "type": "number",
            "minimum": 0,
            "maximum": 3
          }
        }
      },
      "EstimateFeeFromAddress": {
        "type": "object",
        "required": [
          "chain",
          "type",
          "fromAddress",
          "to"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": [
              "BTC",
              "LTC"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": [
              "TRANSFER"
            ]
          },
          "fromAddress": {
            "description": "Array of addresses. Tatum will automatically scan last 100 transactions for each address and will use all of the unspent values. We advise to use this option if you have 1 address per 1 transaction only.",
            "type": "array",
            "items": {
              "type": "string",
              "example": "2N9bBiH2qrTDrPCzrNhaFGdkNKS86PJAAAS",
              "minimum": 30,
              "maximum": 50
            }
          },
          "to": {
            "description": "Array of addresses and values to send bitcoins to. Values must be set in BTC. Difference between from and to is transaction fee.",
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "address",
                "value"
              ],
              "properties": {
                "address": {
                  "description": "Destination address.",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "Amount to be sent, in BTC.",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          }
        }
      },
      "EstimateFeeFromUTXO": {
        "type": "object",
        "required": [
          "chain",
          "type",
          "fromUTXO",
          "to"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Blockchain to estimate fee for.",
            "enum": [
              "BTC",
              "LTC"
            ]
          },
          "type": {
            "type": "string",
            "description": "Type of transaction",
            "enum": [
              "TRANSFER"
            ]
          },
          "fromUTXO": {
            "description": "Array of transaction hashes, index of UTXO in it and corresponding private keys. Use this option if you want to calculate amount to send manually. Either fromUTXO or fromAddress must be present.",
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "txHash",
                "index"
              ],
              "properties": {
                "txHash": {
                  "description": "Transaction hash of the UTXO to be spent.",
                  "type": "string",
                  "example": "53faa103e8217e1520f5149a4e8c84aeb58e55bdab11164a95e69a8ca50f8fcc",
                  "minLength": 64,
                  "maxLength": 64
                },
                "index": {
                  "description": "Index of the UTXO to be spent.",
                  "type": "number",
                  "example": 0,
                  "minimum": 0,
                  "maximum": 2147483647
                }
              }
            }
          },
          "to": {
            "description": "Array of addresses and values to send bitcoins to. Values must be set in BTC. Difference between from and to is transaction fee.",
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "address",
                "value"
              ],
              "properties": {
                "address": {
                  "description": "Destination address.",
                  "type": "string",
                  "example": "2MzNGwuKvMEvKMQogtgzSqJcH2UW3Tc5oc7",
                  "minimum": 30,
                  "maximum": 60
                },
                "value": {
                  "description": "Amount to be sent, in BTC.",
                  "type": "number",
                  "minimum": 0,
                  "example": 0.02969944
                }
              }
            }
          }
        }
      },
      "BlockchainFee": {
        "description": "Recommended fees to perform blockchain transaction",
        "properties": {
          "fast": {
            "description": "Fast transaction acceptance time into block. For btc-based chains - fee per byte. For evm-based chains - gas price in wei",
            "example": 14766927339,
            "type": "number"
          },
          "medium": {
            "description": "Medium transaction acceptance time into block. For btc-based chains - fee per byte. For evm-based chains - gas price in wei",
            "example": 13333333333,
            "type": "number"
          },
          "slow": {
            "description": "Slow transaction acceptance time into block. For btc-based chains - fee per byte. For evm-based chains - gas price in wei",
            "example": 12953333333,
            "type": "number"
          },
          "baseFee": {
            "description": "(evm-based only) This is the minimum fee needs to paid in order for the tx to be accepted into block.",
            "example": 12657357496,
            "type": "number"
          },
          "time": {
            "description": "Last time fees were recalculated",
            "example": "2022-12-08T08:42:04.518Z",
            "type": "string"
          },
          "block": {
            "description": "Last used to calculate fee from",
            "example": "16138867",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "fast",
          "medium",
          "slow",
          "time",
          "block"
        ]
      },
      "PrivKey": {
        "type": "object",
        "properties": {
          "key": {
            "description": "Generated private key.",
            "example": "cTmS2jBWXgFaXZ2xG9jhn67TiyTshnMp3UedamzEhGm6BZV1vLgQ",
            "type": "string"
          }
        }
      },
      "PrivKeyRequest": {
        "type": "object",
        "properties": {
          "index": {
            "description": "Derivation index of private key to generate.",
            "example": 0,
            "maximum": 2147483647,
            "type": "integer"
          },
          "mnemonic": {
            "maxLength": 500,
            "minLength": 1,
            "description": "Mnemonic to generate private key from.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          }
        },
        "required": [
          "mnemonic",
          "index"
        ]
      },
      "CustomFee": {
        "description": "The custom defined fee; if not present, will be calculated automatically",
        "type": "object",
        "required": [
          "gasLimit",
          "gasPrice"
        ],
        "properties": {
          "gasLimit": {
            "type": "string",
            "description": "Gas limit for transaction in gas price.",
            "pattern": "^[+]?\\d+$",
            "example": "40000"
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price in Gwei.",
            "pattern": "^[+]?\\d+$",
            "example": "20"
          }
        }
      },
      "TransactionHash": {
        "type": "object",
        "properties": {
          "txId": {
            "description": "The hash (ID) of the transaction",
            "example": "c83f8818db43d9ba4accfe454aa44fc33123d47a4f89d47b314d6748eb0e9bc9",
            "type": "string"
          }
        },
        "required": [
          "txId"
        ]
      },
      "Data": {
        "type": "object",
        "properties": {
          "data": {
            "description": "Result of the method, if the method was read only.",
            "example": 2,
            "type": "object"
          }
        },
        "required": [
          "data"
        ]
      },
      "SignatureId": {
        "type": "object",
        "properties": {
          "signatureId": {
            "format": "uuid",
            "description": "The internal Tatum ID of the prepared transaction for Key Management Sysytem (KMS) to sign<br/>This is different from the <code>signatureId</code> parameter that you provided in the request body. The <code>signatureId</code> parameter in the request body specifies the signature ID associated with the private key in KMS.",
            "example": "1f7f7c0c-3906-4aa1-9dfe-4b67c43918f6",
            "type": "string"
          }
        },
        "required": [
          "signatureId"
        ]
      },
      "Wallet": {
        "type": "object",
        "properties": {
          "mnemonic": {
            "description": "Generated mnemonic for wallet.",
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "type": "string"
          },
          "xpub": {
            "description": "Generated Extended public key for wallet with derivation path according to BIP44. This key can be used to generate addresses.",
            "example": "xpub6EsCk1uU6cJzqvP9CdsTiJwT2rF748YkPnhv5Qo8q44DG7nn2vbyt48YRsNSUYS44jFCW9gwvD9kLQu9AuqXpTpM1c5hgg9PsuBLdeNncid",
            "type": "string"
          }
        }
      },
      "NftMetadataErc721": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "description": "Metadata associated with token.",
            "example": "https://my_token_data.com"
          }
        }
      },
      "NftProvenanceDataErc721": {
        "type": "object",
        "properties": {
          "provenanceData": {
            "type": "string",
            "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
          },
          "tokenPrice": {
            "type": "string",
            "example": "123"
          }
        }
      },
      "NftRoyaltyErc721": {
        "type": "object",
        "properties": {
          "addresses": {
            "type": "array",
            "description": "The blockchain addresses where the royalty cashback will be sent every time the NFT is transferred",
            "items": {
              "type": "string",
              "example": "0x94Ce79B9F001E25BBEbE7C01998A78F7B27D1326"
            }
          },
          "values": {
            "type": "array",
            "description": "The amounts of the royalties that will be paid to the authors of the NFT every time the NFT is transferred; the royalties are paid as a percentage of the NFT price (on Solana) or in a native blockchain currency (on the other supported blockchains)\n",
            "items": {
              "type": "string",
              "example": "0.2"
            }
          }
        }
      },
      "NftTokenByAddressErc721": {
        "type": "object",
        "required": [
          "contractAddress",
          "balances",
          "metadata"
        ],
        "properties": {
          "contractAddress": {
            "type": "string",
            "example": "43821281",
            "description": "On Algorand, this is the asset ID (the ID of the NFT); on the other blockchains, this is the address of the NFT smart contract"
          },
          "balances": {
            "type": "array",
            "description": "On Algorand, an array of \"1\" to indicate that the NFTs with the specified IDs exist, or array with amount of fractions for <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>; on the other blockchains, this is an array of the IDs of the NFTs.",
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "blockNumber": {
            "type": "array",
            "description": "(EVM-based blockchains only) On EVM-based blockchains like Celo, Polygon or Ethereum, this is an array of block numbers, in which the NFT was received by the address",
            "items": {
              "type": "number",
              "example": 13816552
            }
          },
          "metadata": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NftTokenByAddressErc721TokenMetadata"
            }
          },
          "supply": {
            "type": "number",
            "example": 10,
            "description": "Only on Algorand, shows supply of <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>"
          },
          "decimals": {
            "type": "number",
            "example": 1,
            "description": "Only on Algorand, shows decimals of <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>"
          }
        }
      },
      "NftTokenByAddressErc721TokenMetadata": {
        "type": "object",
        "properties": {
          "tokenId": {
            "description": "(EVM-based blockchains only) The ID of the NFT owned by this address.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; the URL may not be present, and if it is not returned, you can get it by calling the NFT Contract.tokenURI() method",
            "example": "ipfs://QmXFpaS3S7CkLZvihLFA9JbawKdqhjg8dJeDkPntmkD2Pc",
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/NftTokenByAddressErc721Metadata"
          }
        }
      },
      "NftTokenByAddressErc721Metadata": {
        "type": "object",
        "description": "The metadata scheme obtained from the metadata URL; the scheme may not be present, and if it is not returned, you can get it using the <a href=\"#operation/NftGetMetadataErc721\">NFT metadata API</a>",
        "example": {
          "name": "Example NFT name",
          "description": "Example NFT description",
          "image": "ipfs://QmP4R7ACZ7JRQ6sLdmnPHqjWEXxzdnPvhAV2f6RnQ8uxJ6"
        }
      },
      "NftTokenByCollectionErc721": {
        "type": "object",
        "required": [
          "tokenId"
        ],
        "properties": {
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "metadata": {
            "$ref": "#/components/schemas/NftTokenByCollectionErc721TokenMetadata"
          }
        }
      },
      "NftTokenByCollectionErc721TokenMetadata": {
        "type": "object",
        "required": [
          "tokenID"
        ],
        "properties": {
          "tokenId": {
            "description": "TokenID of the NFT token owned by this address.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "Metadata URL of the TokenID. This data don't have to be present, safest way (if not present) is to obtain them from the NFT Contract.tokenURI() method call.",
            "example": "ipfs://QmXFpaS3S7CkLZvihLFA9JbawKdqhjg8dJeDkPntmkD2Pc",
            "type": "string"
          },
          "metadata": {
            "type": "object",
            "description": "Metadata scheme obtained from the url. This data don't have to be present, safest way (if not present) is to obtain them from the NFT Contract.tokenURI() method call.",
            "example": {
              "name": "Example NFT name",
              "description": "Example NFT description",
              "image": "ipfs://QmP4R7ACZ7JRQ6sLdmnPHqjWEXxzdnPvhAV2f6RnQ8uxJ6"
            }
          }
        }
      },
      "TransferNftCelo": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "tokenId",
          "fromPrivateKey",
          "feeCurrency"
        ]
      },
      "TransferNftTron": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to send NFT token to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "tokenId",
          "fromPrivateKey",
          "feeLimit"
        ]
      },
      "FlowMintedMultipleResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "Transaction ID",
            "example": "d67787399d205139f4d6f42c2aa4fffdf6f247411fae3706e874fbba0ce04b1b"
          },
          "tokenId": {
            "type": "array",
            "items": {
              "description": "ID of the minted token.",
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          }
        }
      },
      "FlowMintedResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "Transaction ID",
            "example": "d67787399d205139f4d6f42c2aa4fffdf6f247411fae3706e874fbba0ce04b1b"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          }
        }
      },
      "SolanaMintedResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "The ID of the transaction",
            "example": "4kiRkAWjjr5t3rBKmYQ5d2e3xjgnRRttB5GtUz2F4sz5wwC7NnV74qCZ1KN1b37qsnjkKknsJPGXdcPhzHpkiMAs"
          },
          "nftAddress": {
            "type": "string",
            "description": "The blockchain address of the minted NFT",
            "example": "4afZBmAneN2j6gDHH8zdrNWkCqfMC3XPH2cpFKtYMSVe"
          },
          "nftAccountAddress": {
            "type": "string",
            "description": "The blockchain address that received the minted NFT; this address was created under the recipient's account address (the one in the <code>to</code> parameter of the request body), is owned by the recipient's address, and has the same private key",
            "example": "A8BSHPJcB5ZGCT6yo6pz2RYqnypTSpzTAFSBhtTQmsEE"
          }
        }
      },
      "AlgorandMintedResult": {
        "type": "object",
        "properties": {
          "txId": {
            "type": "string",
            "description": "The ID of the transaction",
            "example": "HQ32RQPJ7EAASLHPG5TTQEGETOEMN7BPND2TQMUMZWLIZBJWJ23A"
          },
          "assetIndex": {
            "type": "number",
            "description": "The ID of the minted NFT",
            "example": 88885810
          },
          "confirmed": {
            "type": "boolean",
            "description": "If set to \"true\", the transaction was included in the block within five rounds; otherwise, returned set to \"false\". \"false\" does not mean that the transaction was not included in the block; the Tatum API just does not wait for that much time to return the response.",
            "example": true
          }
        }
      },
      "MintMultipleNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            ],
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": [
              "123"
            ],
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "type": "array",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency CELO.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockchain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "url",
          "fromPrivateKey",
          "feeCurrency",
          "tokenId"
        ]
      },
      "MintMultipleNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"
            ],
            "items": {
              "maxLength": 34,
              "minLength": 34,
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": [
              "123"
            ],
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "type": "array",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "url",
          "fromPrivateKey",
          "feeLimit",
          "tokenId"
        ]
      },
      "DeployNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "feeCurrency",
          "fromPrivateKey"
        ]
      },
      "DeployNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX); deployment of a smart contract on TRON costs around 580 TRX",
            "example": 600
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "feeLimit",
          "fromPrivateKey"
        ]
      },
      "DeployNftCeloKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used",
            "minimum": 0
          },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "feeCurrency",
          "signatureId"
        ]
      },
      "DeployNftTronKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX); deployment of a smart contract on TRON costs around 580 TRX",
            "example": 600
          }
        },
        "required": [
          "chain",
          "name",
          "account",
          "symbol",
          "feeLimit",
          "signatureId"
        ]
      },
      "MintMultipleNftKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            ],
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": [
              "123"
            ],
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "type": "array",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency CELO.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockchain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used",
            "minimum": 0
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "feeCurrency",
          "tokenId",
          "url",
          "signatureId"
        ]
      },
      "MintMultipleNftKMSTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"
            ],
            "items": {
              "maxLength": 34,
              "minLength": 34,
              "type": "string"
            }
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": [
              "123"
            ],
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "type": "array",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          }
        },
        "required": [
          "chain",
          "to",
          "account",
          "contractAddress",
          "feeLimit",
          "tokenId",
          "url",
          "signatureId"
        ]
      },
      "BurnNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeCurrency",
          "fromPrivateKey",
          "tokenId"
        ]
      },
      "BurnNftAlgo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The ID of the NFT to burn; this is the ID from the <code>assetIndex</code> parameter returned in the response body of the <a href=\"#operation/NftMintErc721\">minting call</a>",
            "example": "116363571",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "46OPDKNDLB35M3QMRRZEAW2HDTDT2LFHRUCHDE5FJZAJOV7GDPCC6AYZ6KCUULTHA4QL6YPHN2PNEXHPJMUZGHYJXQK6SUL2HQ2MLXQ",
            "minLength": 103,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "BurnNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeLimit",
          "fromPrivateKey",
          "tokenId"
        ]
      },
      "BurnNftKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "feeCurrency",
          "contractAddress",
          "tokenId",
          "signatureId"
        ]
      },
      "BurnNftKMSTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          }
        },
        "required": [
          "chain",
          "feeLimit",
          "contractAddress",
          "tokenId",
          "signatureId",
          "account"
        ]
      },
      "BurnNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "privateKey",
          "tokenId"
        ]
      },
      "BurnNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "mnemonic",
          "index",
          "tokenId"
        ]
      },
      "BurnNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "tokenId": {
            "description": "ID of token to be destroyed.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "signatureId",
          "tokenId"
        ]
      },
      "MintMultipleNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0xc1b45bc27b9c61c3"
            ],
            "items": {
              "maxLength": 18,
              "minLength": 18,
              "type": "string"
            }
          },
          "url": {
            "type": "array",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "privateKey",
          "to",
          "url"
        ]
      },
      "MintMultipleNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0xc1b45bc27b9c61c3"
            ],
            "items": {
              "maxLength": 18,
              "minLength": 18,
              "type": "string"
            }
          },
          "url": {
            "type": "array",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "mnemonic",
          "index",
          "to",
          "url"
        ]
      },
      "MintMultipleNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0xc1b45bc27b9c61c3"
            ],
            "items": {
              "maxLength": 18,
              "minLength": 18,
              "type": "string"
            }
          },
          "url": {
            "type": "array",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "signatureId",
          "to",
          "url"
        ]
      },
      "MintNftFlowPK": {
        "description": "<p>The <code>MintNftFlowPK</code> schema lets you mint NFTs natively on Flow and sign the transaction with your private key.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "url": {
            "type": "string",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "privateKey",
          "to",
          "url"
        ]
      },
      "MintNftFlowMnemonic": {
        "description": "<p>The <code>MintNftFlowMnemonic</code> schema lets you mint NFTs natively on Flow and sign the transaction with your wallet mnemonic.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "url": {
            "type": "string",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "mnemonic",
          "index",
          "to",
          "url"
        ]
      },
      "MintNftFlowKMS": {
        "description": "<p>The <code>MintNftFlowKMS</code> schema lets you mint NFTs natively on Flow and sign the transaction with your signature ID.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "url": {
            "type": "string",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "maxLength": 256
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "signatureId",
          "to",
          "url"
        ]
      },
      "DeployNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": [
          "chain",
          "account",
          "privateKey"
        ]
      },
      "DeployNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "account",
          "mnemonic",
          "index"
        ]
      },
      "DeployNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "account",
          "signatureId"
        ]
      },
      "TransferNftFlowPK": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "tokenId": {
            "description": "ID of token to be sent.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "privateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 64,
            "description": "Private key of sender address. Private key, mnemonic and index or signature Id must be present."
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "privateKey",
          "to",
          "tokenId"
        ]
      },
      "TransferNftFlowMnemonic": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "tokenId": {
            "description": "ID of token to be sent.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "mnemonic": {
            "type": "string",
            "maxLength": 500,
            "example": "urge pulp usage sister evidence arrest palm math please chief egg abuse",
            "minLength": 1,
            "description": "Mnemonic to generate private key of sender address."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "mnemonic",
          "index",
          "to",
          "tokenId"
        ]
      },
      "TransferNftFlowKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "FLOW",
            "description": "The blockchain to work with",
            "enum": [
              "FLOW"
            ]
          },
          "to": {
            "type": "string",
            "description": "Blockchain address to send NFT token to.",
            "example": "0xc1b45bc27b9c61c3",
            "maxLength": 18,
            "minLength": 18
          },
          "tokenId": {
            "description": "ID of token to be sent.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 36,
            "minLength": 36,
            "description": "Address of NFT token",
            "example": "17a50dad-bcb1-4f3d-ae2c-ea2bfb04419f",
            "type": "string"
          },
          "account": {
            "type": "string",
            "maxLength": 18,
            "example": "0xc1b45bc27b9c61c3",
            "minLength": 18,
            "description": "Blockchain address of the sender account."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "index": {
            "description": "Derivation index of sender address.",
            "example": 0,
            "type": "integer",
            "maximum": 2147483647
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "account",
          "signatureId",
          "to",
          "tokenId"
        ]
      },
      "NftTx": {
        "type": "object",
        "properties": {
          "blockNumber": {
            "type": "number",
            "example": 6541235,
            "description": "Block number"
          },
          "txId": {
            "type": "string",
            "example": "0x955c1037608c7aecb6d1a3f150ce7d0a80536bcabb0deb69d62f55292cc4c372",
            "description": "Transaction ID"
          },
          "contractAddress": {
            "type": "string",
            "example": "0x4f54fAD27F7F46C102Cd49b8E75C5593397cd9c3",
            "description": "Contract address"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "from": {
            "type": "string",
            "example": "0x780c3de0aba1b51f04cfe8a5d9d277d4ad032b8d",
            "description": "Sender"
          },
          "to": {
            "type": "string",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea",
            "description": "recipient"
          }
        },
        "required": [
          "blockNumber",
          "txId",
          "contractAddress",
          "tokenId",
          "from",
          "to"
        ]
      },
      "UpdateCashbackValueForAuthorNftCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to update royalty information for.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT to update royalty information for",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "cashbackValue": {
            "type": "string",
            "description": "The new value of the royalty cashback to be set for the author of the NFT; to disable the royalties for the NFT completely, set this parameter to 0",
            "example": "0.1"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the NFT author's address"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeCurrency",
          "fromPrivateKey",
          "tokenId",
          "cashbackValue"
        ]
      },
      "UpdateCashbackValueForAuthorNftTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to update royalty information for.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address of the NFT to update royalty information for",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "cashbackValue": {
            "type": "string",
            "description": "The new value of the royalty cashback to be set for the author of the NFT; to disable the royalties for the NFT completely, set this parameter to 0",
            "example": "0.1"
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "The private key of the NFT author's address"
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeLimit",
          "fromPrivateKey",
          "tokenId",
          "cashbackValue"
        ]
      },
      "UpdateCashbackValueForAuthorNftKMSCelo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to update royalty information for.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT to update royalty information for",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "cashbackValue": {
            "type": "string",
            "description": "The new value of the royalty cashback to be set for the author of the NFT; to disable the royalties for the NFT completely, set this parameter to 0",
            "example": "0.1"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the NFT author's address"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the NFT author's address that was generated from the mnemonic"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "feeCurrency",
          "contractAddress",
          "tokenId",
          "signatureId",
          "cashbackValue"
        ]
      },
      "UpdateCashbackValueForAuthorNftKMSTron": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to update royalty information for.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address of the NFT to update royalty information for",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "cashbackValue": {
            "type": "string",
            "description": "The new value of the royalty cashback to be set for the author of the NFT; to disable the royalties for the NFT completely, set this parameter to 0",
            "example": "0.1"
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address of the NFT author from which the transaction will be performed",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the NFT author's address"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the NFT author's address that was generated from the mnemonic"
          }
        },
        "required": [
          "chain",
          "feeLimit",
          "contractAddress",
          "account",
          "tokenId",
          "signatureId",
          "cashbackValue"
        ]
      },
      "TransferNftKMSCelo": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "feeCurrency",
          "signatureId",
          "tokenId"
        ]
      },
      "TransferNftKMSTron": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to perform transaction from",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Blockchain address to send NFT token to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "Address of NFT token",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "feeLimit",
          "signatureId",
          "tokenId",
          "account"
        ]
      },
      "MintNftCelo": {
        "description": "<p>The <code>MintNftCelo</code> schema lets you mint NFTs natively on Celo and sign the transaction with your private key.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the NFT to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "The ID of the NFT.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that will pay the fee for the transaction"
          },
          "erc20": {
            "type": "string",
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the custom fungible token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
          },
          "provenance": {
            "description": "Set to \"true\" if the NFT smart contract is of the <a href=\"#operation/NftDeployErc721\">provenance type</a>; otherwise, set to \"false\".",
            "example": true,
            "type": "boolean"
          },
          "authorAddresses": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred; the royalties are paid in the native blockchain currency, CELO",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "The amounts of the royalties that will be paid to the authors of the minted NFT every time the NFT is transferred; the amount is defined as a fixed amount of the native blockchain currency for <a href=\"#operation/NftDeployErc721\">cashback smart contracts</a> or as a percentage of the NFT price for <a href=\"#operation/NftDeployErc721\">provenance smart contracts</a>",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          },
          "fixedValues": {
            "type": "array",
            "description": "The fixed amounts of the native blockchain currency to which the cashback royalty amounts will be compared to; if the fixed amount specified in this parameter is greater than the amount of the cashback royalties, this fixed amount will be sent to the NFT authors instead of the cashback royalties",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "to",
          "url",
          "feeCurrency",
          "tokenId",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "MintNftTron": {
        "type": "object",
        "description": "<p>The <code>MintNftTron</code> schema lets you mint NFTs natively on TRON and sign the transaction with your private key.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address to send the NFT to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "The ID of the NFT.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 64,
            "example": "842E09EB40D8175979EFB0071B28163E11AED0F14BDD84090A4CEFB936EF5701",
            "minLength": 64,
            "description": "The private key of the blockchain address that will pay the fee for the transaction"
          },
          "authorAddresses": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred; the royalties are paid in the native blockchain currency, TRX",
            "items": {
              "type": "string",
              "minLength": 34,
              "maxLength": 34,
              "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "The amounts of the royalties that will be paid to the authors of the minted NFT every time the NFT is transferred; the amount is defined as a fixed amount of the native blockchain currency",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          }
        },
        "required": [
          "chain",
          "to",
          "url",
          "feeLimit",
          "contractAddress",
          "fromPrivateKey",
          "tokenId"
        ]
      },
      "MintNftKMSCelo": {
        "description": "<p>The <code>MintNftKMSCelo</code> schema lets you mint NFTs natively on Celo and sign the transaction with your signature ID.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the NFT to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "The ID of the NFT.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that will pay the fee for the transaction"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the address to pay the transaction fee that was generated from the mnemonic"
          },
          "erc20": {
            "type": "string",
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the custom fungible token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
          },
          "provenance": {
            "description": "Set to \"true\" if the NFT smart contract is of the <a href=\"#operation/NftDeployErc721\">provenance type</a>; otherwise, set to \"false\".",
            "example": true,
            "type": "boolean"
          },
          "authorAddresses": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred; the royalties are paid in the native blockchain currency, CELO",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "The amounts of the royalties that will be paid to the authors of the minted NFT every time the NFT is transferred; the amount is defined as a fixed amount of the native blockchain currency for <a href=\"#operation/NftDeployErc721\">cashback smart contracts</a> or as a percentage of the NFT price for <a href=\"#operation/NftDeployErc721\">provenance smart contracts</a>",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          },
          "fixedValues": {
            "type": "array",
            "description": "The fixed amounts of the native blockchain currency to which the cashback royalty amounts will be compared to; if the fixed amount specified in this parameter is greater than the amount of the cashback royalties, this fixed amount will be sent to the NFT authors instead of the cashback royalties",
            "items": {
              "type": "string",
              "description": "Value of the royalty to be paid.",
              "example": "0.5"
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "to",
          "url",
          "feeCurrency",
          "contractAddress",
          "signatureId",
          "tokenId"
        ]
      },
      "MintNftKMSTron": {
        "type": "object",
        "description": "<p>The <code>MintNftKMSTron</code> schema lets you mint NFTs natively on TRON and sign the transaction with your signature ID.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "properties": {
          "chain": {
            "type": "string",
            "example": "TRON",
            "description": "The blockchain to work with",
            "enum": [
              "TRON"
            ]
          },
          "to": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address to send the NFT to",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "tokenId": {
            "description": "The ID of the NFT.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "feeLimit": {
            "type": "number",
            "description": "The maximum amount to be paid as the transaction fee (in TRX)",
            "example": 600
          },
          "account": {
            "maxLength": 34,
            "minLength": 34,
            "description": "The blockchain address that will pay the fee for the transaction",
            "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that will pay the fee for the transaction"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the address to pay the transaction fee that was generated from the mnemonic"
          },
          "authorAddresses": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred; the royalties are paid in the native blockchain currency, TRX",
            "items": {
              "type": "string",
              "minLength": 34,
              "maxLength": 34,
              "example": "TCrmdJmvDUPy8qSTgoVStF51yWm6VUh5yQ"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "The amounts of the royalties that will be paid to the authors of the minted NFT every time the NFT is transferred; the amount is defined as a fixed amount of the native blockchain currency",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          }
        },
        "required": [
          "chain",
          "account",
          "to",
          "url",
          "feeLimit",
          "contractAddress",
          "signatureId",
          "tokenId"
        ]
      },
      "TransferNft": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "to": {
            "maxLength": 58,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 1,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "contractAddress",
          "tokenId",
          "fromPrivateKey"
        ]
      },
      "TransferNftAlgo": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "to": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "contractAddress": {
            "description": "AssetID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "72TCV5BRQPBMSAFPYO3CPWVDBYWNGAYNMTW5QHENOMQF7I6QLNMJWCJZ7A3V5YKD7QD6ZZPEHG2PV2ZVVEDDO6BCRGXWIL3DIUMSUCI",
            "minLength": 106,
            "description": "Private key of sender address."
          },
          "amount": {
            "description": "The total amount of NFT fractions to transfer. Defaults to 1 - which means 1 fraction of NFT will be transferred. This is only valid for <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>",
            "example": 1,
            "default": 1,
            "minimum": 1,
            "type": "number"
          }
        },
        "required": [
          "to",
          "chain",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "TransferNftAlgoExpress": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "to": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "contractAddress": {
            "description": "AssetID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "amount": {
            "description": "The total amount of NFT fractions to transfer. Defaults to 1 - which means 1 fraction of NFT will be transferred. This is only valid for <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>",
            "example": 1,
            "default": 1,
            "type": "number",
            "minimum": 0
          }
        },
        "required": [
          "to",
          "chain",
          "contractAddress"
        ]
      },
      "TransferNftSolana": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "from": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT from; this is the address that you used in the <code>to</code> parameter in the request body of the <a href=\"#operation/NftMintErc721\">minting call</a>; from this address, the transaction fee will be paid",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "to": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address of the NFT; this is the address from the <code>nftAddress</code> parameter returned in the response body of the <a href=\"#operation/NftMintErc721\">minting call</a>",
            "example": "3tzudv5KaoqmieWiBUqzWokKEtTvx1wQMapVKeH7CHaq",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 128,
            "description": "The private key of the blockchain address that you are sending the NFT from (the address that you specified in the <code>from</code> parameter)"
          }
        },
        "required": [
          "to",
          "from",
          "chain",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "TransferNftAlgoKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "from": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token from",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "to": {
            "maxLength": 58,
            "minLength": 58,
            "description": "Blockchain address to send NFT token to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "contractAddress": {
            "description": "AssetID of token.",
            "example": "100000",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "amount": {
            "description": "The total amount of NFT fractions to transfer. Defaults to 1 - which means 1 fraction of NFT will be transferred. This is only valid for <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>",
            "example": 1,
            "default": 1,
            "type": "number",
            "minimum": 0
          }
        },
        "required": [
          "to",
          "chain",
          "contractAddress",
          "from",
          "signatureId"
        ]
      },
      "TransferNftSolanaKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "from": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT from; this is the address that you used in the <code>to</code> parameter in the request body of the <a href=\"#operation/NftMintErc721\">minting call</a>; from this address, the transaction fee will be paid",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "to": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 44,
            "minLength": 44,
            "description": "The blockchain address of the NFT; this is the address from the <code>nftAddress</code> parameter returned in the response body of the <a href=\"#operation/NftMintErc721\">minting call</a>",
            "example": "3tzudv5KaoqmieWiBUqzWokKEtTvx1wQMapVKeH7CHaq",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that you are sending the NFT from (the address that you specified in the <code>from</code> parameter)"
          }
        },
        "required": [
          "to",
          "from",
          "chain",
          "contractAddress",
          "signatureId"
        ]
      },
      "DeployNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of account address, from which gas for deployment of ERC721 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "maxLength": 103,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66
          },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "name",
          "chain",
          "symbol",
          "fromPrivateKey"
        ]
      },
      "DeployNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "name": {
            "description": "Name of the NFT token",
            "example": "My ERC721",
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "provenance": {
            "description": "True if the contract is provenance percentage royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "cashback": {
            "description": "True if the contract is fixed price royalty type. False by default. <a href=\"https://github.com/tatumio/smart-contracts\" target=\"_blank\">Details and sources available here.</a>",
            "example": false,
            "type": "boolean"
          },
          "publicMint": {
            "description": "True if the contract is publicMint type. False by default.",
            "example": true,
            "type": "boolean"
          },
          "symbol": {
            "description": "Symbol of the NFT token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "name",
          "chain",
          "symbol",
          "signatureId"
        ]
      },
      "TransferNftKMS": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "If token to be transferred is Royalty NFT token, this is a value to be paid as a cashback to the authors of the token.",
            "example": "1"
          },
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send NFT token to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "ID of the token.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "provenance": {
            "description": "True if the contract is provenance type",
            "example": true,
            "type": "boolean"
          },
          "provenanceData": {
            "description": "data you want to store with transaction, optional and valid only if provenance contract",
            "example": "test",
            "type": "string"
          },
          "tokenPrice": {
            "description": "current price of the token, valid only for provenance",
            "example": "1",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "example": 1,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "contractAddress",
          "signatureId",
          "tokenId"
        ]
      },
      "MintNft": {
        "description": "<p>The <code>MintNft</code> schema lets you mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, and Polygon and sign the transaction with your private key.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "ETH",
              "KLAY",
              "KCS",
              "MATIC",
              "ONE"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the NFT to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "The ID of the NFT.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address that will pay the fee for the transaction"
          },
          "erc20": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the custom fungible token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "provenance": {
            "description": "Set to \"true\" if the NFT smart contract is of the <a href=\"#operation/NftDeployErc721\">provenance type</a>; otherwise, set to \"false\".",
            "example": true,
            "type": "boolean"
          },
          "authorAddresses": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred; the royalties are paid in a native blockchain currency such as ETH on Ethereum, MATIC on Polygon, and so on",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "The amounts of the royalties that will be paid to the authors of the minted NFT every time the NFT is transferred; the amount is defined as a fixed amount of the native blockchain currency for <a href=\"#operation/NftDeployErc721\">cashback smart contracts</a> or as a percentage of the NFT price for <a href=\"#operation/NftDeployErc721\">provenance smart contracts</a>",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          },
          "fixedValues": {
            "type": "array",
            "description": "The fixed amounts of the native blockchain currency to which the cashback royalty amounts will be compared to; if the fixed amount specified in this parameter is greater than the amount of the cashback royalties, this fixed amount will be sent to the NFT authors instead of the cashback royalties",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "fromPrivateKey",
          "tokenId",
          "contractAddress"
        ]
      },
      "MintNftMinter": {
        "description": "<p>The <code>MintNftMinter</code> schema lets you mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, and Polygon using the <b>NTF minter</b>, a special blockchain address provided by Tatum that will cover the minting fees.<br/>For more information, see \"Use your own smart contract to mint NFTs\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "CELO",
              "ETH",
              "KLAY",
              "MATIC",
              "ONE"
            ]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the Tatum NFT minter; this is the address that you added as an NFT minter to your NFT smart contract",
            "example": "0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94",
            "type": "string"
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the NFT to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "The ID of the NFT.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "minter",
          "tokenId",
          "contractAddress"
        ]
      },
      "MintNftExpress": {
        "description": "<p>The <code>MintNftExpress</code> schema lets you mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, and Polygon using <b>NTF Express</b> with the pre-built smart contract provided by Tatum.<br/>For more information, see \"Use the pre-built smart contract provided by Tatum to mint NFTs\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "CELO",
              "ETH",
              "KLAY",
              "MATIC",
              "ONE"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the NFT to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          }
        },
        "required": [
          "to",
          "chain",
          "url"
        ]
      },
      "MintNftExpressAlgorand": {
        "description": "<p>The <code>MintNftExpressAlgorand</code> schema lets you mint NFTs on Algorand using <b>NTF Express</b> with the pre-built smart contract provided by Tatum.<br/>For more information, see \"Use the pre-built smart contract provided by Tatum to mint NFTs\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "name": {
            "description": "The name of the NFT",
            "example": "My Crazy NFT",
            "maxLength": 32,
            "minLength": 1,
            "type": "string"
          },
          "attr": {
            "type": "object",
            "properties": {
              "assetUnit": {
                "description": "The unit name of the NFT",
                "example": "USDT",
                "type": "string",
                "maxLength": 8,
                "minLength": 1
              },
              "total": {
                "description": "The total amount of the NFTs to mint. Defaults to 1 - which means 1 NFT will be minted.<br/>Value above 1 means, you are going to mint <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>In this case value must be a power of 10 larger than 1 e.g. 10, 100, 1000...",
                "example": 10,
                "default": 1,
                "type": "number",
                "minimum": 10
              },
              "decimals": {
                "description": "The decimal places of the NFT to mint. Defaults to 0 - which means 1 NFT will be minted.<br/>Value above 0 means, you are going to mint <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>In this case value must be equal to the logarithm in base 10 of total number of units (e.g. for total = 10, decimal will be 1)",
                "example": 1,
                "default": 0,
                "type": "number",
                "minimum": 1,
                "maximum": 15
              },
              "clawback": {
                "description": "The address of the clawback account that can claw back holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "manager": {
                "description": "The address of the manager account that can manage the configuration of the NFT or burn it; specify this parameter if you want to be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFT</a> any time later",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "reserve": {
                "description": "The address of the reserve account that holds the reserve (non-minted) units of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "freeze": {
                "description": "The address of the freeze account that is used to freeze holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              }
            }
          }
        },
        "required": [
          "name",
          "chain",
          "url"
        ]
      },
      "MintNftAlgorand": {
        "description": "<p>The <code>MintNftAlgorand</code> schema lets you mint NFTs natively on Algorand and sign the transaction with your private key.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "name": {
            "description": "The name of the NFT",
            "example": "My Crazy NFT",
            "maxLength": 32,
            "minLength": 1,
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "EPD5VYFGXWNZ2PY4AQNPD3E3LMAXISKNMGR4IJ44YI74QL5AMNTAIJNQ6Q373RDANF2YERVFQY3C5CKK7VUJDJR4DT6EPP5HZQUPORQ",
            "minLength": 103,
            "description": "The private key of the minting account; the transaction fee will be paid from this account"
          },
          "attr": {
            "type": "object",
            "properties": {
              "assetUnit": {
                "description": "The unit name of the NFT",
                "example": "USDT",
                "type": "string",
                "maxLength": 8,
                "minLength": 1
              },
              "clawback": {
                "description": "The address of the clawback account that can claw back holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "manager": {
                "description": "The address of the manager account that can manage the configuration of the NFT or burn it; specify this parameter if you want to be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFT</a> any time later",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "reserve": {
                "description": "The address of the reserve account that holds the reserve (non-minted) units of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "freeze": {
                "description": "The address of the freeze account that is used to freeze holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "total": {
                "description": "The total amount of the NFTs to mint. Defaults to 1 - which means 1 NFT will be minted.<br/>Value above 1 means, you are going to mint <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>In this case value must be a power of 10 larger than 1 e.g. 10, 100, 1000...",
                "example": 10,
                "default": 1,
                "type": "number",
                "minimum": 10
              },
              "decimals": {
                "description": "The decimal places of the NFT to mint. Defaults to 0 - which means 1 NFT will be minted.<br/>Value above 0 means, you are going to mint <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>In this case value must be equal to the logarithm in base 10 of total number of units (e.g. for total = 10, decimal will be 1)",
                "example": 1,
                "default": 0,
                "type": "number",
                "minimum": 1,
                "maximum": 15
              }
            }
          }
        },
        "required": [
          "name",
          "chain",
          "url",
          "fromPrivateKey"
        ]
      },
      "MintNftAlgorandKMS": {
        "description": "<p>The <code>MintNftAlgorandKMS</code> schema lets you mint NFTs natively on Algorand and sign the transaction with your signature ID.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "name": {
            "description": "The name of the NFT",
            "example": "My Crazy NFT",
            "maxLength": 32,
            "minLength": 1,
            "type": "string"
          },
          "from": {
            "description": "The address of the minting account",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string",
            "maxLength": 58,
            "minLength": 58
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the minting account; the transaction fee will be paid from this account"
          },
          "attr": {
            "type": "object",
            "properties": {
              "assetUnit": {
                "description": "The unit name of the NFT",
                "example": "USDT",
                "type": "string",
                "maxLength": 8,
                "minLength": 1
              },
              "clawback": {
                "description": "The address of the clawback account that can claw back holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "manager": {
                "description": "The address of the manager account that can manage the configuration of the NFT or burn it; specify this parameter if you want to be able to <a href=\"#operation/NftBurnErc721\">burn the minted NFT</a> any time later",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "reserve": {
                "description": "The address of the reserve account that holds the reserve (non-minted) units of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "freeze": {
                "description": "The address of the freeze account that is used to freeze holdings of the NFT",
                "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
                "type": "string",
                "maxLength": 58,
                "minLength": 58
              },
              "total": {
                "description": "The total amount of the NFTs to mint. Defaults to 1 - which means 1 NFT will be minted.<br/>Value above 1 means, you are going to mint <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>In this case value must be a power of 10 larger than 1 e.g. 10, 100, 1000...",
                "example": 10,
                "default": 1,
                "type": "number",
                "minimum": 10
              },
              "decimals": {
                "description": "The decimal places of the NFT to mint. Defaults to 0 - which means 1 NFT will be minted.<br/>Value above 0 means, you are going to mint <a href=\"https://developer.algorand.org/docs/get-started/tokenization/nft/#fractional-nfts\" target=\"_blank\">Fractional NFTs.</a>In this case value must be equal to the logarithm in base 10 of total number of units (e.g. for total = 10, decimal will be 1)",
                "example": 1,
                "default": 0,
                "type": "number",
                "minimum": 1,
                "maximum": 15
              }
            }
          }
        },
        "required": [
          "name",
          "chain",
          "url",
          "from",
          "signatureId"
        ]
      },
      "MintNftKMS": {
        "description": "<p>The <code>MintNftKMS</code> schema lets you mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, and Polygon and sign the transaction with your signature ID.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "ETH",
              "KLAY",
              "KCS",
              "MATIC",
              "ONE"
            ]
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to send the NFT to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the smart contract to build the NFT on",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "tokenId": {
            "description": "The ID of the NFT.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "url": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 256
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that will pay the fee for the transaction"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the address to pay the transaction fee that was generated from the mnemonic"
          },
          "erc20": {
            "type": "string",
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the custom fungible token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
          },
          "provenance": {
            "description": "Set to \"true\" if the NFT smart contract is of the <a href=\"#operation/NftDeployErc721\">provenance type</a>; otherwise, set to \"false\".",
            "example": true,
            "type": "boolean"
          },
          "authorAddresses": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred; the royalties are paid in a native blockchain currency such as ETH on Ethereum, MATIC on Polygon, and so on",
            "items": {
              "type": "string",
              "minLength": 42,
              "maxLength": 42,
              "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "The amounts of the royalties that will be paid to the authors of the minted NFT every time the NFT is transferred; the amount is defined as a fixed amount of the native blockchain currency for <a href=\"#operation/NftDeployErc721\">cashback smart contracts</a> or as a percentage of the NFT price for <a href=\"#operation/NftDeployErc721\">provenance smart contracts</a>",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          },
          "fixedValues": {
            "type": "array",
            "description": "The fixed amounts of the native blockchain currency to which the cashback royalty amounts will be compared to; if the fixed amount specified in this parameter is greater than the amount of the cashback royalties, this fixed amount will be sent to the NFT authors instead of the cashback royalties",
            "items": {
              "type": "string",
              "example": "0.5"
            }
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "contractAddress",
          "signatureId",
          "tokenId"
        ]
      },
      "MintNftSolana": {
        "type": "object",
        "description": "<p>The <code>MintNftSolana</code> schema lets you mint NFTs natively on Solana and sign the transaction with your private key.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "to": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address that will pay the fee for the transaction",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 64,
            "description": "The private key of the blockchain address that will pay the fee for the transaction"
          },
          "collectionVerifierPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 64,
            "description": "The private key of the collection verifier (owner) who will verify the NFT in the NFT collection where the NFT is minted in. The blockchain address of this collection is specified in the <code>collection</code> parameter in the <code>metadata</code> section of the request body. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>."
          },
          "metadata": {
            "$ref": "#/components/schemas/SolanaNftMetadata"
          }
        },
        "required": [
          "to",
          "chain",
          "fromPrivateKey",
          "from",
          "metadata"
        ]
      },
      "VerifySolanaNFT": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "nftAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT to verify",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "collectionAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT should be verified in. The collection must be a sized collection that was introduced in <a href=\"https://docs.metaplex.com/programs/token-metadata/changelog/v1.3\" target=\"_blank\">Version 1.3</a> of the Metaplex Token Metadata program.",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the collection verifier on behalf of whom the transaction will be originated. The transaction fee will be paid from this address.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 128,
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "minLength": 64,
            "description": "The private key of the collection verifier's address"
          }
        },
        "required": [
          "collectionAddress",
          "chain",
          "fromPrivateKey",
          "from",
          "nftAddress"
        ]
      },
      "VerifySolanaNFTKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "nftAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT to verify",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "collectionAddress": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT should be verified in. The collection must be a sized collection that was introduced in <a href=\"https://docs.metaplex.com/programs/token-metadata/changelog/v1.3\" target=\"_blank\">Version 1.3</a> of the Metaplex Token Metadata program.",
            "example": "CHw1Fy5YdbaaosLXrrxhuc3X3fpssMqDQm9XwJh9LPGe",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the collection verifier on behalf of whom the transaction will be originated. The transaction fee will be paid from this address.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": [
          "collectionAddress",
          "chain",
          "signatureId",
          "from",
          "nftAddress"
        ]
      },
      "MintNftExpressSolana": {
        "description": "<p>The <code>MintNftExpressSolana</code> schema lets you mint NFTs on Solana using <b>NTF Express</b> with the pre-built smart contract provided by Tatum.<br/>For more information, see \"Use the pre-built smart contract provided by Tatum to mint NFTs\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "to": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address to send the NFT to",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/SolanaNftExpressMetadata"
          }
        },
        "required": [
          "to",
          "chain",
          "metadata"
        ]
      },
      "MintNftSolanaKMS": {
        "type": "object",
        "description": "<p>The <code>MintNftSolanaKMS</code> schema lets you mint NFTs natively on Solana and sign the transaction with your signature ID.<br/>For more information, see \"Minting NFTs natively on a blockchain\" in <a href=\"#operation/NftMintErc721\">Mint an NFT</a>.</p><br/>",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "to": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address to send the NFT to",
            "example": "9pSkqSG71Sb25ia9WBFhoeBYjp8dhUf7fRux9xrDq89b",
            "type": "string"
          },
          "from": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address that will pay the fee for the transaction",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that will pay the fee for the transaction"
          },
          "metadata": {
            "$ref": "#/components/schemas/SolanaNftMetadataKMS"
          }
        },
        "required": [
          "to",
          "chain",
          "signatureId",
          "metadata",
          "from"
        ]
      },
      "SolanaNftMetadataCreator": {
        "type": "object",
        "required": [
          "address",
          "verified",
          "share"
        ],
        "properties": {
          "address": {
            "type": "string",
            "description": "The blockchain address of the NFT creator",
            "maxLength": 44,
            "minLength": 43,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ"
          },
          "verified": {
            "type": "boolean",
            "description": "If set to \"true\", the NFT creator was verified. Only the address whose private key was used during the minting of the NFT can be a verified creator. If you are minting the NFT using NFT Express, set this parameter to \"false\".",
            "example": true
          },
          "share": {
            "type": "number",
            "description": "The share to be sent to the NFT creator (in %)",
            "example": 100
          }
        }
      },
      "SolanaNftMetadata": {
        "type": "object",
        "required": [
          "name",
          "symbol",
          "uri",
          "sellerFeeBasisPoints"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the NFT",
            "example": "My NFT",
            "maxLength": 255
          },
          "symbol": {
            "type": "string",
            "description": "The symbol or abbreviated name of the NFT",
            "example": "NFT_SYMBOL",
            "maxLength": 255
          },
          "sellerFeeBasisPoints": {
            "type": "number",
            "description": "The royalty that will be paid to the authors of the minted NFT every time the NFT is transferred<br/>The royalty is calculated as a percentage of the NFT price. To set the royalty to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.<br/>To specify the NFT authors and their shares in the royalty, set the <code>creators</code> parameter.<br/>To disable the royalty for the NFT completely, set <code>sellerFeeBasisPoints</code> to <code>0</code> and do not set <code>creators</code>.",
            "example": 0
          },
          "uri": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 500
          },
          "collection": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT will be minted in. Specify the private key of the collection verifier in the <code>collectionVerifierPrivateKey</code> parameter of the request body to get the NFT verified in the collection after the NFT has been minted. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "mutable": {
            "type": "boolean",
            "default": true,
            "description": "Specifies whether the NFT metadata is mutable (\"true\") or immutable (\"false\"); if not set, defaults to \"true\""
          },
          "creators": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred",
            "items": {
              "$ref": "#/components/schemas/SolanaNftMetadataCreator"
            }
          }
        }
      },
      "SolanaNftMetadataKMS": {
        "type": "object",
        "required": [
          "name",
          "symbol",
          "uri",
          "sellerFeeBasisPoints"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the NFT",
            "example": "My NFT",
            "maxLength": 255
          },
          "symbol": {
            "type": "string",
            "description": "The symbol or abbreviated name of the NFT",
            "example": "NFT_SYMBOL",
            "maxLength": 255
          },
          "sellerFeeBasisPoints": {
            "type": "number",
            "description": "The royalty that will be paid to the authors of the minted NFT every time the NFT is transferred<br/>The royalty is calculated as a percentage of the NFT price. To set the royalty to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.<br/>To specify the NFT authors and their shares in the royalty, set the <code>creators</code> parameter.<br/>To disable the royalty for the NFT completely, set <code>sellerFeeBasisPoints</code> to <code>0</code> and do not set <code>creators</code>.",
            "example": 0
          },
          "uri": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 500
          },
          "collection": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT will be minted in. The minted NFT will get verified in the collection on behalf of the blockchain address specified in the <code>from</code> parameter. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a> and <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftVerifyInCollection\" target=\"_blank\">NFT verification API</a>.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "mutable": {
            "type": "boolean",
            "default": true,
            "description": "Specifies whether the NFT metadata is mutable (\"true\") or immutable (\"false\"); if not set, defaults to \"true\""
          },
          "creators": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred",
            "items": {
              "$ref": "#/components/schemas/SolanaNftMetadataCreator"
            }
          }
        }
      },
      "SolanaNftExpressMetadata": {
        "type": "object",
        "required": [
          "name",
          "symbol",
          "uri",
          "sellerFeeBasisPoints"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the NFT",
            "example": "My NFT",
            "maxLength": 255
          },
          "symbol": {
            "type": "string",
            "description": "The symbol or abbreviated name of the NFT",
            "example": "NFT_SYMBOL",
            "maxLength": 255
          },
          "sellerFeeBasisPoints": {
            "type": "number",
            "description": "The royalty that will be paid to the authors of the minted NFT every time the NFT is transferred<br/>The royalty is calculated as a percentage of the NFT price. To set the royalty to 1%, set this parameter to <code>100</code>; to set 10%, set this parameter to <code>1000</code>; to set 50%, set this parameter to <code>5000</code>, and so on.<br/>To specify the NFT authors and their shares in the royalty, set the <code>creators</code> parameter.<br/>To disable the royalty for the NFT completely, set <code>sellerFeeBasisPoints</code> to <code>0</code> and do not set <code>creators</code>.",
            "example": 0
          },
          "uri": {
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": "https://my_token_data.com",
            "type": "string",
            "maxLength": 500
          },
          "collection": {
            "maxLength": 44,
            "minLength": 43,
            "description": "The blockchain address of the NFT collection where the NFT will be minted in. By default, the NFT is minted as not verified (is not considered a part of the collection). To verify the NFT in the collection, use the <a href=\"https://apidoc.tatum.io/tag/NFT-(ERC-721-or-compatible)#operation/NftVerifyInCollection\" target=\"_blank\">NFT verification API</a>. To know more about Solana collections and verification, refer to the <a href=\"https://docs.metaplex.com/programs/token-metadata/certified-collections\" target=\"_blank\">Solana user documentation</a>.",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "mutable": {
            "type": "boolean",
            "default": true,
            "description": "Specifies whether the NFT metadata is mutable (\"true\") or immutable (\"false\"); if not set, defaults to \"true\""
          },
          "creators": {
            "type": "array",
            "description": "The blockchain addresses where the royalties will be sent every time the minted NFT is transferred",
            "items": {
              "$ref": "#/components/schemas/SolanaNftMetadataCreator"
            }
          }
        }
      },
      "MintMultipleNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            ],
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": [
              "123"
            ],
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "url": {
            "type": "array",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency, ETH or BSC.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockchain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "contractAddress",
          "fromPrivateKey",
          "tokenId"
        ]
      },
      "MintMultipleNftMinter": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "CELO",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            ],
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": [
              "123"
            ],
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "minter": {
            "maxLength": 42,
            "minLength": 43,
            "description": "Address of NFT minter, which will be used to mint the tokens. From this address, transaction fees will be deducted.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "url": {
            "type": "array",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "feeCurrency": {
            "type": "string",
            "description": "(Celo only) The currency in which the transaction fee will be paid",
            "enum": [
              "CELO"
            ]
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "contractAddress",
          "minter",
          "tokenId"
        ]
      },
      "MintMultipleNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "to": {
            "type": "array",
            "description": "Blockchain address to send NFT token to.",
            "example": [
              "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
            ],
            "items": {
              "maxLength": 42,
              "minLength": 42,
              "type": "string"
            }
          },
          "tokenId": {
            "type": "array",
            "description": "ID of token to be created.",
            "example": [
              "123"
            ],
            "items": {
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          },
          "url": {
            "type": "array",
            "description": "The URL pointing to the NFT metadata; for more information, see <a href=\"https://eips.ethereum.org/EIPS/eip-721#specification\" target=\"_blank\">EIP-721</a>",
            "example": [
              "https://my_token_data.com"
            ],
            "items": {
              "type": "string",
              "maxLength": 256
            }
          },
          "authorAddresses": {
            "type": "array",
            "description": "List of addresses for every token, where royalty cashback for every transfer of this NFT will be send. Royalties are paid in native blockchain currency, ETH or BSC.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 42,
                "maxLength": 42,
                "description": "Blockchain address to send royalties to",
                "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85"
              }
            }
          },
          "cashbackValues": {
            "type": "array",
            "description": "List of values for every token, which will be paid as a royalty for author of the NFT token with every token transfer. This is exact value in native blockchain currency.",
            "items": {
              "type": "array",
              "items": {
                "type": "string",
                "description": "Value of the royalty to be paid.",
                "example": "0.5"
              }
            }
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of NFT token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "contractAddress",
          "tokenId",
          "url",
          "signatureId"
        ]
      },
      "BurnNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to burn.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 1,
            "description": "The blockchain address of the NFT to burn",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "contractAddress",
          "fromPrivateKey",
          "tokenId"
        ]
      },
      "AddNftMinter": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "CELO",
              "ETH",
              "KLAY",
              "KCS",
              "MATIC",
              "ONE"
            ]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to add to the smart contract as an NFT minter",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "feeCurrency": {
            "type": "string",
            "description": "(Celo only) The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "minter",
          "chain",
          "url",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "UpdateCashbackValueForAuthorNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "ETH",
              "KCS",
              "KLAY",
              "MATIC",
              "ONE"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to update royalty information for.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT to update royalty information for",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "cashbackValue": {
            "type": "string",
            "description": "The new value of the royalty cashback to be set for the author of the NFT; to disable the royalties for the NFT completely, set this parameter to 0",
            "example": "0.1"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the NFT author's address"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the NFT author's address that was generated from the mnemonic"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "contractAddress",
          "tokenId",
          "cashbackValue",
          "signatureId"
        ]
      },
      "UpdateCashbackValueForAuthorNft": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "ETH",
              "KCS",
              "KLAY",
              "MATIC",
              "ONE"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to update royalty information for.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT to update royalty information for",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "cashbackValue": {
            "type": "string",
            "description": "The new value of the royalty cashback to be set for the author of the NFT; to disable the royalties for the NFT completely, set this parameter to 0",
            "example": "0.1"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the NFT author's address"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "cashbackValue",
          "contractAddress",
          "fromPrivateKey",
          "tokenId"
        ]
      },
      "BurnNftKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "MATIC",
              "KCS",
              "ONE",
              "KLAY",
              "BSC"
            ]
          },
          "tokenId": {
            "description": "The ID of the NFT to burn.",
            "type": "string",
            "maxLength": 78,
            "example": "123",
            "format": "uint256"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT to burn",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the address to pay the transaction fee that was generated from the mnemonic"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "to",
          "chain",
          "url",
          "contractAddress",
          "tokenId",
          "signatureId"
        ]
      },
      "AddNftMinterKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "BSC",
              "CELO",
              "ETH",
              "KLAY",
              "KCS",
              "MATIC",
              "ONE"
            ]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the NFT smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "minter": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to add to the smart contract as an NFT minter",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address from which the fee will be deducted"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "(Only if the signature ID is mnemonic-based) The index of the address to pay the transaction fee that was generated from the mnemonic"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "feeCurrency": {
            "type": "string",
            "description": "(Celo only) The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "url",
          "contractAddress",
          "minter",
          "signatureId"
        ]
      },
      "NftGetBalanceSc": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "description": "The array returning the ID of the NFTs",
            "items": {
              "description": "The ID of the NFT.",
              "type": "string",
              "maxLength": 78,
              "example": "123",
              "format": "uint256"
            }
          }
        }
      },
      "NftGetBalanceScAlgo": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "required": [
              "contractAddress",
              "balances"
            ],
            "items": {
              "type": "object",
              "properties": {
                "contractAddress": {
                  "type": "string",
                  "description": "The asset ID (the ID of the NFT)",
                  "example": "116227380"
                },
                "balances": {
                  "type": "array",
                  "description": "The array returning <code>1</code> to indicate that the NFT with the specified ID exists",
                  "items": {
                    "type": "string",
                    "example": "1"
                  }
                },
                "metadata": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "url": {
                        "description": "The URL pointing to the NFT metadata; may not be present",
                        "example": "ipfs://QmXFpaS3S7CkLZvihLFA9JbawKdqhjg8dJeDkPntmkD2Pc",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "Erc20BalanceForAddress": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "type": "string",
            "description": "The address of the smart contract that the fungible tokens were minted on"
          },
          "amount": {
            "type": "string",
            "description": "The number of the fungible tokens",
            "example": "10"
          }
        }
      },
      "Erc20Balance": {
        "type": "object",
        "properties": {
          "balance": {
            "type": "string",
            "description": "The number of fungible tokens in the smallest token unit (for example, if the token has 10 decimal places, the number is returned as 9*10^10)",
            "example": "10"
          }
        }
      },
      "ChainDeployErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "fromPrivateKey",
          "digits"
        ]
      },
      "ChainDeploySolanaSpl": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "supply": {
            "description": "Initial supply of SPL token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "address": {
            "description": "Address on Solana blockchain, where all created SPL tokens will be transferred.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "from": {
            "description": "Address on Solana blockchain, from which the fee for the deployment of SPL will be paid.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Solana account address, from which the fee for the deployment of SPL will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "3abc79a31093e4cfa4a724e94a44906cbbc3a32e2f75f985a28616676a5dbaf1de8d82a7e1d0561bb0e1b729c7a9b9b1708cf2803ad0ca928a332587ace391ad",
            "maxLength": 103,
            "minLength": 128
          }
        },
        "required": [
          "chain",
          "from",
          "address",
          "supply",
          "fromPrivateKey",
          "digits"
        ]
      },
      "ChainDeploySolanaSplKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "supply": {
            "description": "Initial supply of SPL token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "address": {
            "description": "Address on Solana blockchain, where all created SPL tokens will be transferred.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "from": {
            "description": "Address on Solana blockchain, from which the fee for the deployment of SPL will be paid.",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": [
          "chain",
          "from",
          "address",
          "supply",
          "signatureId",
          "digits"
        ]
      },
      "FungibleTx": {
        "type": "object",
        "properties": {
          "blockNumber": {
            "type": "number",
            "example": 6541235,
            "description": "Block number"
          },
          "txId": {
            "type": "string",
            "example": "0x955c1037608c7aecb6d1a3f150ce7d0a80536bcabb0deb69d62f55292cc4c372",
            "description": "Transaction ID"
          },
          "contractAddress": {
            "type": "string",
            "example": "0x4f54fAD27F7F46C102Cd49b8E75C5593397cd9c3",
            "description": "Contract address"
          },
          "amount": {
            "type": "string",
            "example": "1",
            "description": "Amount of tokens transferred, in smallest decimals"
          },
          "from": {
            "type": "string",
            "example": "0x780c3de0aba1b51f04cfe8a5d9d277d4ad032b8d",
            "description": "Sender"
          },
          "to": {
            "type": "string",
            "example": "0x8cb76aed9c5e336ef961265c6079c14e9cd3d2ea",
            "description": "recipient"
          }
        },
        "required": [
          "txId",
          "blockNumber",
          "contractAddress",
          "amount",
          "from",
          "to"
        ]
      },
      "ChainDeployErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "signatureId",
          "digits"
        ]
      },
      "ChainDeployKcsErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "fromPrivateKey",
          "digits"
        ]
      },
      "ChainDeployKcsErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 43,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "signatureId",
          "digits"
        ]
      },
      "ChainDeployAlgoErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 8,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 32,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 19,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 58,
            "minLength": 42,
            "example": "52NRXAHUDA5RKC7Q6YYJHBINGTJB7NXLUVY3CSKOBLLNLTKCN2NGPRGTN0",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "GDNQECUM2JDPTA4KXNSXHQBAYL56FDZ73NXCQ2OLB32PN2G5BLNO5GY3QD2BQOYVBPYPMMETQUGTJUQ7W3V2K4NRJFHAVVWVZVBG5G2",
            "maxLength": 103,
            "minLength": 103
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "fromPrivateKey",
          "digits"
        ]
      },
      "ChainDeployAlgoErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 8,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 32,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Initial supply of ERC20 token. If totalCap is not defined, this will be the total cap.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 19,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 58,
            "minLength": 42,
            "example": "52NRXAHUDA5RKC7Q6YYJHBINGTJB7NXLUVY3CSKOBLLNLTKCN2NGPRGTN0",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "signatureId",
          "digits"
        ]
      },
      "ChainDeployCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "fromPrivateKey": {
            "description": "Private key of Ethereum account address, from which the fee for the deployment of ERC20 will be paid. Private key, or signature Id must be present.",
            "type": "string",
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "maxLength": 66,
            "minLength": 66
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "fromPrivateKey",
          "digits",
          "feeCurrency"
        ]
      },
      "ChainDeployCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "symbol": {
            "description": "Symbol of the ERC20 token",
            "example": "ERC_SYMBOL",
            "maxLength": 30,
            "minLength": 1,
            "type": "string"
          },
          "name": {
            "description": "Name of the ERC20 token",
            "example": "MyERC20",
            "maxLength": 100,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9_]+$",
            "type": "string"
          },
          "totalCap": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "supply": {
            "description": "Max supply of ERC20 token.",
            "maxLength": 38,
            "example": "10000000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "digits": {
            "description": "Number of decimal points",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "address": {
            "description": "Address on Ethereum blockchain, where all created ERC20 tokens will be transferred.",
            "maxLength": 42,
            "minLength": 42,
            "example": "0xa0Ca9FF38Bad06eBe64f0fDfF279cAE35129F5C6",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "name",
          "symbol",
          "address",
          "supply",
          "signatureId",
          "digits",
          "feeCurrency"
        ]
      },
      "ChainMintErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE"
            ]
          },
          "amount": {
            "description": "Amount to be minted and transferred to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "to",
          "amount",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "ChainMintKcsErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "amount": {
            "description": "Amount to be minted and transferred to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "to",
          "amount",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "ChainMintErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE"
            ]
          },
          "amount": {
            "description": "Amount to be minted and transferred to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "to",
          "amount",
          "contractAddress",
          "signatureId"
        ]
      },
      "ChainMintKcsErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "amount": {
            "description": "Amount to be minted and transferred to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "to",
          "amount",
          "contractAddress",
          "signatureId"
        ]
      },
      "ChainMintCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "amount": {
            "description": "Amount to be minted and transferred to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "amount",
          "feeCurrency",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "ChainMintCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "amount": {
            "description": "Amount to be minted and transferred to the recipient.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "to": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Blockchain address to send ERC-20 tokens to.",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC-20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "amount",
          "feeCurrency",
          "contractAddress",
          "signatureId"
        ]
      },
      "ApproveErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "ONE"
            ]
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The blockchain address to be allowed to transfer or burn the fungible tokens",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the tokens allowed to be transferred or burnt",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the smart contract's owner; the fee will be deducted from the owner's address"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "spender",
          "amount",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "ApproveErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "ONE"
            ]
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The blockchain address to be allowed to transfer or burn the fungible tokens",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the tokens allowed to be transferred or burnt",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the smart contract's owner; the fee will be deducted from the owner's address"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "spender",
          "amount",
          "contractAddress",
          "signatureId"
        ]
      },
      "ApproveCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to be allowed to transfer or burn the fungible tokens",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the tokens allowed to be transferred or burnt",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the smart contract's owner; the fee will be deducted from the owner's address"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "spender",
          "amount",
          "feeCurrency",
          "contractAddress",
          "fromPrivateKey"
        ]
      },
      "ApproveCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "spender": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address to be allowed to transfer or burn the fungible tokens",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the tokens allowed to be transferred or burnt",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the smart contract's owner; the fee will be deducted from the owner's address"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "spender",
          "amount",
          "feeCurrency",
          "contractAddress",
          "signatureId"
        ]
      },
      "ChainBurnErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE",
              "ALGO"
            ]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "fromPrivateKey",
          "amount"
        ]
      },
      "ChainBurnErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE",
              "ALGO"
            ]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "signatureId",
          "amount"
        ]
      },
      "ChainBurnKcsErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "fromPrivateKey",
          "amount"
        ]
      },
      "ChainBurnKcsErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "signatureId",
          "amount"
        ]
      },
      "ChainBurnCeloErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeCurrency",
          "fromPrivateKey",
          "amount"
        ]
      },
      "ChainBurnCeloErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "amount": {
            "description": "Amount of tokens to be destroyed.",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "Address of ERC20 token",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "contractAddress",
          "feeCurrency",
          "signatureId",
          "amount"
        ]
      },
      "ChainTransferAlgoErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "to": {
            "maxLength": 58,
            "minLength": 42,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 1,
            "description": "The asset ID (the ID of the fungible tokens)",
            "example": "1",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 103,
            "example": "72TCV5BRQPBMSAFPYO3CPWVDBYWNGAYNMTW5QHENOMQF7I6QLNMJWCJZ7A3V5YKD7QD6ZZPEHG2PV2ZVVEDDO6BCRGXWIL3DIUMSUCI",
            "minLength": 103,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "amount",
          "digits",
          "fromPrivateKey"
        ]
      },
      "ChainTransferAlgoErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ALGO",
            "description": "The blockchain to work with",
            "enum": [
              "ALGO"
            ]
          },
          "from": {
            "maxLength": 58,
            "minLength": 42,
            "description": "The blockchain address to send the fungible tokens from",
            "example": "NTAESFCB3WOD7SAOL42KSPVARLB3JFA3MNX3AESWHYVT2RMYDVZI6YLG4Y",
            "type": "string"
          },
          "to": {
            "maxLength": 58,
            "minLength": 42,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "TMETT6BXL3QUH7AH5TS6IONU7LVTLKIGG54CFCNPMQXWGRIZFIESZBYWP4",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 1,
            "description": "The asset ID (the ID of the fungible tokens)",
            "example": "1",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that you are sending the fungible tokens from (the address that you specified in the <code>from</code> parameter); the transaction fee will be deducted from this address"
          }
        },
        "required": [
          "chain",
          "from",
          "to",
          "contractAddress",
          "amount",
          "digits",
          "signatureId"
        ]
      },
      "ChainTransferEthErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The blockchain address of the fungible token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have; to find out how many decimal places are used in the fungible tokens, check out the <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">smart contract</a>",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "currency",
          "to",
          "contractAddress",
          "digits",
          "fromPrivateKey",
          "amount"
        ]
      },
      "ChainTransferSolanaSpl": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "from": {
            "description": "The blockchain address to send the fungible tokens from",
            "maxLength": 44,
            "minLength": 43,
            "example": "BL4Xgn1jkuU4Yr3SQ4HG8cD5SBrsSk7BihKzkb5zTUfs",
            "type": "string"
          },
          "to": {
            "description": "The blockchain address to send the fungible tokens to",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 44,
            "description": "The blockchain address of the fungible tokens",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 87,
            "example": "YdQ1iy2NYs93dtkHdz3ijDuhRJj6uXYAUZmixirCrgCsTMj42BN1Q1buYcGZaMxw5buk9VU5ogQ6zuzn8DMsGaf",
            "minLength": 128,
            "description": "The private key of the blockchain address that you are sending the fungible tokens from (the address that you specified in the <code>from</code> parameter); the transaction fee will be deducted from this address"
          },
          "feePayer": {
            "description": "The blockchain address from which the fee will be deducted; if not set, defaults to the address that you specified in the <code>from</code> parameter",
            "maxLength": 44,
            "minLength": 43,
            "example": "BL4Xgn1jkuU4Yr3SQ4HG8cD5SBrsSk7BihKzkb5zTUfs",
            "type": "string"
          },
          "feePayerPrivateKey": {
            "type": "string",
            "maxLength": 87,
            "example": "YdQ1iy2NYs93dtkHdz3ijDuhRJj6uXYAUZmixirCrgCsTMj42BN1Q1buYcGZaMxw5buk9VU5ogQ6zuzn8DMsGaf",
            "minLength": 128,
            "description": "The private key of the blockchain address that you specified in the <code>feePayer</code> parameter; if not set, defaults to the private key that you specified in the <code>fromPrivateKey</code> parameter"
          }
        },
        "required": [
          "chain",
          "currency",
          "to",
          "contractAddress",
          "digits",
          "fromPrivateKey",
          "from",
          "amount"
        ]
      },
      "ChainTransferSolanaSplKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "SOL",
            "description": "The blockchain to work with",
            "enum": [
              "SOL"
            ]
          },
          "from": {
            "description": "The blockchain address to send the fungible tokens from",
            "maxLength": 44,
            "minLength": 43,
            "example": "BL4Xgn1jkuU4Yr3SQ4HG8cD5SBrsSk7BihKzkb5zTUfs",
            "type": "string"
          },
          "to": {
            "description": "The blockchain address to send the fungible tokens to",
            "maxLength": 43,
            "minLength": 44,
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 44,
            "description": "The blockchain address of the fungible tokens",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have",
            "example": 18,
            "maximum": 30,
            "minimum": 0,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that you are sending the fungible tokens from (the address that you specified in the <code>from</code> parameter); the transaction fee will be deducted from this address"
          },
          "feePayer": {
            "description": "The blockchain address from which the fee will be deducted; if not set, defaults to the address that you specified in the <code>from</code> parameter",
            "example": "FykfMwA9WNShzPJbbb9DNXsfgDgS3XZzWiFgrVXfWoPJ",
            "maxLength": 44,
            "minLength": 43,
            "type": "string"
          },
          "feePayerSignatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address that you specified in the <code>feePayer</code> parameter; if not set, defaults to the signature ID that you specified in the <code>signatureId</code> parameter"
          }
        },
        "required": [
          "chain",
          "currency",
          "to",
          "contractAddress",
          "digits",
          "signatureId",
          "from",
          "amount"
        ]
      },
      "ChainTransferEthErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "ETH",
            "description": "The blockchain to work with",
            "enum": [
              "ETH",
              "BSC",
              "MATIC",
              "KLAY",
              "XDC",
              "ONE"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The blockchain address of the fungible token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have; to find out how many decimal places are used in the fungible tokens, check out the <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">smart contract</a>",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "currency",
          "to",
          "contractAddress",
          "digits",
          "signatureId",
          "amount"
        ]
      },
      "ChainTransferKcsEthErc20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The blockchain address of the fungible token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "currency",
          "to",
          "contractAddress",
          "digits",
          "fromPrivateKey",
          "amount"
        ]
      },
      "ChainTransferKcsEthErc20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "KCS",
            "description": "The blockchain to work with",
            "enum": [
              "KCS"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 43,
            "minLength": 42,
            "description": "The blockchain address of the fungible token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "currency",
          "to",
          "contractAddress",
          "digits",
          "signatureId",
          "amount"
        ]
      },
      "ChainTransferBscBep20": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "BSC",
            "description": "The blockchain to work with",
            "enum": [
              "BSC"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the fungible tokens",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have; to find out how many decimal places are used in the fungible tokens, check out the <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">smart contract</a>",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "digits",
          "fromPrivateKey",
          "amount"
        ]
      },
      "ChainTransferBscBep20KMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "BSC",
            "description": "The blockchain to work with",
            "enum": [
              "BSC"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the fungible tokens",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have; to find out how many decimal places are used in the fungible tokens, check out the <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">smart contract</a>",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "digits",
          "signatureId",
          "amount"
        ]
      },
      "ChainTransferCeloErc20Token": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the fungible token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have; to find out how many decimal places are used in the fungible tokens, check out the <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">smart contract</a>",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "The private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "digits",
          "feeCurrency",
          "fromPrivateKey",
          "amount"
        ]
      },
      "ChainTransferCeloErc20TokenKMS": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "example": "CELO",
            "description": "The blockchain to work with",
            "enum": [
              "CELO"
            ]
          },
          "to": {
            "maxLength": 50,
            "minLength": 1,
            "description": "The blockchain address to send the fungible tokens to",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The blockchain address of the fungible token smart contract",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "amount": {
            "description": "The amount of the fungible tokens to be sent",
            "example": "100000",
            "type": "string",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$"
          },
          "digits": {
            "description": "The number of decimal places that the fungible tokens have; to find out how many decimal places are used in the fungible tokens, check out the <a href=\"https://apidoc.tatum.io/tag/Blockchain-utils#operation/SCGetContractAddress\" target=\"_blank\">smart contract</a>",
            "example": 18,
            "maximum": 30,
            "minimum": 1,
            "type": "number"
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "The KMS identifier of the private key of the blockchain address from which the fee will be deducted"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "The nonce to be set to the transaction; if not present, the last known nonce will be used"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency in which the transaction fee will be paid",
            "enum": [
              "CELO",
              "CUSD",
              "CEUR"
            ]
          }
        },
        "required": [
          "chain",
          "to",
          "contractAddress",
          "digits",
          "feeCurrency",
          "signatureId",
          "amount"
        ]
      },
      "MaticBalance": {
        "type": "object",
        "properties": {
          "balance": {
            "type": "string",
            "description": "Balance in MATIC",
            "example": "10.52"
          }
        }
      },
      "GeneratedAddressMatic": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "Polygon address",
            "example": "0xa7673161CbfE0116A4De9E341f8465940c2211d4"
          }
        }
      },
      "PolygonTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "description": "The number of the block that the transaction is included in; if not returned, the transaction has not been included in a block yet.",
            "example": 6470854,
            "type": "number",
            "nullable": true
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": {
            "type": "number",
            "description": "Gas provided by the sender.",
            "example": 21000
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "description": "The integer of the transactions index position in the block; if not returned, the transaction has not been included in a block yet.",
            "example": 3,
            "type": "number",
            "nullable": true
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "description": "The amount of gas used by this specific transaction alone; if not returned, the transaction has not been included in a block yet.",
            "example": 21000,
            "type": "number",
            "nullable": true
          },
          "cumulativeGasUsed": {
            "description": "The total amount of gas used when this transaction was executed in the block; if not returned, the transaction has not been included in a block yet.",
            "example": 314159,
            "type": "number",
            "nullable": true
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "$ref": "#/components/schemas/PolygonTxLog"
            }
          }
        }
      },
      "PolygonTxLog": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "From which this event originated from.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "topics": {
            "type": "array",
            "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
            "items": {
              "type": "string",
              "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
            }
          },
          "data": {
            "type": "string",
            "description": "The data containing non-indexed log parameter."
          },
          "logIndex": {
            "type": "number",
            "description": "Integer of the event index position in the block."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "blockHash": {
            "description": "Hash of the block.",
            "type": "string",
            "example": "0x5d40698ee1b1ec589035f2a39c6162287e9056868cc79d66cfb248ba9f66c3fc"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transaction’s index position, the event was created in."
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction this event was created in.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          }
        }
      },
      "CallPolygonSmartContractMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0xC9c8ba8C7e2EAF43e84330Db08915A8106d7bD74",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": [
              "0x632"
            ],
            "items": {
              "type": "string",
              "description": "Parameters of the method to be invoked"
            }
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "contractAddress",
          "params",
          "methodABI",
          "fromPrivateKey",
          "methodName"
        ]
      },
      "CallPolygonSmartContractMethodCaller": {
        "type": "object",
        "properties": {
          "caller": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the account, which will be sender and fee payer of this transaction",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "type": "string"
          },
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0xC9c8ba8C7e2EAF43e84330Db08915A8106d7bD74",
            "type": "string"
          },
          "amount": {
            "description": "Amount of the assets to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": [
              "0x632"
            ],
            "items": {
              "type": "string",
              "description": "Parameters of the method to be invoked"
            }
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "contractAddress",
          "params",
          "methodABI",
          "fromPrivateKey",
          "methodName",
          "caller"
        ]
      },
      "CallPolygonSmartContractReadMethod": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0xC9c8ba8C7e2EAF43e84330Db08915A8106d7bD74",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "example": {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "name": "stake",
              "outputs": [],
              "stateMutability": "nonpayable",
              "type": "function"
            },
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": [
              "0x632"
            ],
            "items": {
              "type": "string",
              "description": "Parameters of the method to be invoked"
            }
          }
        },
        "required": [
          "contractAddress",
          "params",
          "methodABI",
          "methodName"
        ]
      },
      "CallPolygonSmartContractMethodKMS": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "maxLength": 42,
            "minLength": 42,
            "description": "The address of the smart contract",
            "example": "0xC9c8ba8C7e2EAF43e84330Db08915A8106d7bD74",
            "type": "string"
          },
          "methodName": {
            "minLength": 1,
            "maxLength": 500,
            "description": "Name of the method to invoke on smart contract.",
            "type": "string",
            "example": "transfer"
          },
          "methodABI": {
            "type": "object",
            "description": "ABI of the method to invoke."
          },
          "params": {
            "type": "array",
            "example": [
              "0x632"
            ],
            "items": {
              "type": "string"
            },
            "description": "Parameters of the method to be invoked."
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          }
        },
        "required": [
          "contractAddress",
          "params",
          "methodABI",
          "signatureId",
          "methodName"
        ]
      },
      "TransferPolygonBlockchain": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data that can be passed to a blockchain transaction as a data property; must be in the hexadecimal format",
            "example": "4d79206e6f746520746f2074686520726563697069656e74"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Polygon Blockchain Account. ERC20 tokens USDC and USDT are available only for mainnet use.",
            "enum": [
              "MATIC",
              "USDC_MATIC",
              "USDT_MATIC"
            ],
            "example": "MATIC",
            "type": "string"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "fromPrivateKey": {
            "type": "string",
            "maxLength": 66,
            "example": "0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2",
            "minLength": 66,
            "description": "Private key of sender address. Private key, or signature Id must be present."
          }
        },
        "required": [
          "to",
          "amount",
          "currency",
          "fromPrivateKey"
        ]
      },
      "PolygonEstimateGas": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "maxLength": 42,
            "example": "0xfb99f8ae9b70a0c8cd96ae665bbaf85a7e01a2ef",
            "minLength": 42,
            "description": "Sender address."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "amount": {
            "description": "Amount to be sent in MATIC.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data that can be passed to a blockchain transaction as a data property; must be in the hexadecimal format",
            "example": "4d79206e6f746520746f2074686520726563697069656e74",
            "pattern": "^(0x|0h)?[0-9A-F]+$"
          }
        },
        "required": [
          "to",
          "amount",
          "from"
        ]
      },
      "TransferPolygonBlockchainKMS": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "maxLength": 50000,
            "description": "Additional data that can be passed to a blockchain transaction as a data property; must be in the hexadecimal format",
            "example": "4d79206e6f746520746f2074686520726563697069656e74"
          },
          "nonce": {
            "type": "number",
            "minimum": 0,
            "description": "Nonce to be set to Polygon transaction. If not present, last known nonce will be used."
          },
          "to": {
            "description": "Blockchain address to send assets",
            "example": "0x687422eEA2cB73B5d3e242bA5456b782919AFc85",
            "maxLength": 42,
            "minLength": 42,
            "type": "string"
          },
          "currency": {
            "description": "Currency to transfer from Polygon Blockchain Account. ERC20 tokens BETH, BBTC, BADA, WMATIC, BDOT, BXRP, BLTC, BBCH are available only for mainnet use.",
            "enum": [
              "BETH",
              "BBTC",
              "BADA",
              "WMATIC",
              "BDOT",
              "BXRP",
              "BLTC",
              "BBCH",
              "MATIC"
            ],
            "example": "MATIC",
            "type": "string"
          },
          "fee": {
            "$ref": "#/components/schemas/CustomFee"
          },
          "amount": {
            "description": "Amount to be sent.",
            "example": "100000",
            "pattern": "^[+]?((\\d+(\\.\\d*)?)|(\\.\\d+))$",
            "type": "string"
          },
          "index": {
            "type": "number",
            "minimum": 0,
            "description": "If signatureId is mnemonic-based, this is the index to the specific address from that mnemonic."
          },
          "signatureId": {
            "type": "string",
            "format": "uuid",
            "example": "26d3883e-4e17-48b3-a0ee-09a3e484ac83",
            "description": "Identifier of the private key associated in signing application. Private key, or signature Id must be present."
          }
        },
        "required": [
          "to",
          "amount",
          "currency",
          "signatureId"
        ]
      },
      "CeloTx": {
        "type": "object",
        "properties": {
          "blockHash": {
            "description": "Hash of the block where this transaction was in.",
            "type": "string",
            "example": "0xcf2c40f475e78c7c19778e1ae999a0e371c9319b38182ea15dc94536f13f9137"
          },
          "status": {
            "type": "boolean",
            "example": true,
            "description": "TRUE if the transaction was successful, FALSE, if the EVM reverted the transaction."
          },
          "blockNumber": {
            "type": "number",
            "description": "Block number where this transaction was in.",
            "example": 6470854
          },
          "from": {
            "type": "string",
            "description": "Address of the sender.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "gas": {
            "type": "number",
            "description": "Gas provided by the sender.",
            "example": 21000
          },
          "gasPrice": {
            "type": "string",
            "description": "Gas price provided by the sender in wei.",
            "example": "1000000000"
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction.",
            "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
          },
          "input": {
            "type": "string",
            "description": "The data sent along with the transaction.",
            "example": "0x"
          },
          "nonce": {
            "type": "number",
            "description": "The number of transactions made by the sender prior to this one.",
            "example": 26836405
          },
          "to": {
            "type": "string",
            "description": "Address of the receiver. 'null' when its a contract creation transaction.",
            "example": "0xbC546fa1716Ed886967cf73f40e8F2F5e623a92d"
          },
          "transactionIndex": {
            "type": "number",
            "description": "Integer of the transactions index position in the block.",
            "example": 3
          },
          "value": {
            "type": "string",
            "description": "Value transferred in wei.",
            "example": "1000000000000000000"
          },
          "gasUsed": {
            "type": "number",
            "description": "The amount of gas used by this specific transaction alone.",
            "example": 21000
          },
          "cumulativeGasUsed": {
            "type": "number",
            "description": "The total amount of gas used when this transaction was executed in the block.",
            "example": 314159
          },
          "contractAddress": {
            "type": "string",
            "description": "The contract address created, if the transaction was a contract creation, otherwise null.",
            "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
          },
          "logs": {
            "type": "array",
            "description": "Log events, that happened in this transaction.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "From which this event originated from.",
                  "example": "0x81b7E08F65Bdf5648606c89998A9CC8164397647"
                },
                "topics": {
                  "type": "array",
                  "description": "An array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the log.",
                  "items": {
                    "type": "string",
                    "example": "0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234"
                  }
                },
                "data": {
                  "type": "string",
                  "description": "The data containing non-indexed log parameter."
                },
                "logIndex": {
                  "type": "number",
                  "description": "Integer of the event index position in the block."
                },
                "transactionIndex": {
                  "type": "number",
                  "description": "Integer of the transaction’s index position, the event was created in."
                },
                "transactionHash": {
                  "type": "string",
                  "description": "Hash of the transaction this event was created in.",
                  "example": "0xe6e7340394958674cdf8606936d292f565e4ecc476aaa8b258ec8a141f7c75d7"
                }
              }
            }
          }
        }
      }
    },
    "securitySchemes": {
      "X-API-Key": {
        "type": "apiKey",
        "name": "x-api-key",
        "in": "header",
        "description": "The **API key** represents your [pricing plan](https://tatum.io/pricing) and defines how many API calls \nyou can make per second and what the total number of API calls per month is available for you.\n\nOne API key must be used by only one person.\n\nChoose one of the following authentication methods:\n\n* **Provide the API key in each API call.**\n\n  To obtain the API key, [create a Tatum account](https://dashboard.tatum.io/sign-up). Once you are logged in,\n  you are automatically assigned the Free plan.\n\n  With the Free plan:\n  * You get two API keys, one tied to the testnet of a blockchain and the other to the mainnet.\n  * You can make up to five API calls per second.\n  * The number of API calls per month is not limited.\n\n  When making an API call, provide the appropriate API key (testnet or mainnet) as either an HTTP header\n  or a path parameter of the API call.\n\n  If you ever need your API keys, you can find them in [your Tatum account](https://dashboard.tatum.io/).\n\n* **Get an auto-generated API key attached to API calls.**\n\n  Make an API call without any API key provided. The API key will be generated and tied to your IP address.\n  This API key is stored within the Tatum platform and is automatically attached to all your API calls.\n\n  With the auto-generated API key:\n  * You can make up to five API calls per second.\n  * You get 10,000,000 credits to spend on API calls within a month.\n\n    The number of credits is reset on the first day of a month. The unused credits from the current month are not\n    rolled over to the next month.\n\n  These limits are applied to both the testnet and mainnet.\n\n  By default, API calls with the auto-generated API key are executed against the mainnet.\n  To make an API call to the testnet, add the `type` query parameter set to `testnet` to the endpoint URL,\n  for example:\n\n  `https://api.tatum.io/v3/ledger/account?type=testnet`\n"
      }
    }
  }
}